[[smart_contracts_chapter]]
== 智能合约和Solidity

正如我们在<<intro_chapter>>中讨论的那样，以太坊中有两种不同类型的帐户：外部拥有帐户（EOA）和合约帐户。 EOA由用户控制，通常通过诸如以太坊平台外部的钱包应用程序之类的软件来控制。相反，合约账户由以太坊虚拟机执行的程序代码（通常也称为“智能合约”）控制。简而言之，EOA是简单的帐户，没有任何相关的代码或数据存储，而合约帐户同时具有相关的代码和数据存储。 EOA由在协议外部和独立于协议的“真实世界”中的私钥创建和加密签名的交易控制，而合约账户没有私钥，因此以它们的智能合约代码规定的预定方式“控制自己”。两种类型的帐户都由以太坊地址标识。在本章中，我们将讨论合约账户和控制它们的程序代码。

[[smart_contracts_definition]]
=== 什么是智能合约

多年来，智能合约一词被用来描述各种不同的东西。在20世纪90年代，密码学家尼克·萨博（Nick Szabo）创造了这一术语，并将其定义为“一系列承诺，以数字形式指定，包括各方在其他承诺上履行的协议。”从那时起，智能合约的概念得到了发展，尤其是在2009年发布比特币的去中心化区块链平台之后。在以太坊的上下文中，这个词实际上有点用词不当，因为以太坊智能合约既不智能也不合法，但这个术语已经约定俗称。在本书中，我们使用术语“智能合约”来指代在以太坊虚拟机的上下文中作为以太坊网络协议的一部分确定性地运行的不可变计算机程序，即在去中心化的以太坊世界计算机上。

让我们解开这个定义：

Computer programs（计算机程序）::
智能合约只是计算机程序。在这个上下文中，“合约”一词没有法律意义。

Immutable（不可变性）::
部署后，智能合约的代码无法更改。与传统软件不同，修改智能合约的唯一方法是部署新实例。

Deterministic（确定性）::
给定启动合约执行的交易以及执行时的以太坊区块链的状态的上下文，智能合约的执行结果对于运行它的每个人都是相同的。

EVM上下文::
智能合约的执行上下文非常有限。它们可以访问自己的状态，访问调用它们的交易的上下文，以及有关最新区块的一些信息。

去中心化的世界计算机::
EVM作为每个以太坊节点上的本地实例运行，但由于EVM的所有实例都在相同的初始状态下运行并产生相同的最终状态，因此整个系统作为单个“世界计算机”运行。

[[smart_contract_lifecycle]]
=== 智能合约的生命周期

智能合约通常用高级语言编写，例如Solidity。但是为了运行，必须将它们编译为在EVM中运行的低级字节码。编译完成后，它们将使用特殊的合约创建交易部署在以太坊平台上，该交易通过发送到特殊合约创建地址（即0x0（参见<<contract_reg>>）来创建合约。每个合约都由以太坊地址标识，该地址是从作为发起帐户和nonce的函数的合约创建交易中派生的。合约的以太坊地址可以作为接收者在交易中使用，将资金发送给合约或调用合约的一个函数。请注意，与EOA不同，没有与为一个新智能合约创建的帐户关联的密钥。作为合约创建者，你不会在协议级别获得任何特殊权限（尽管你可以明确地将它们编码到智能合约中）。你当然不会收到合约帐户的私钥，这实际上并不存在 - 我们可以说智能合约帐户拥有自己。

重要的是，合约只有在被交易调用时才会运行。由于从EOA发起的交易，以太坊中的所有智能合约最终都会被执行。合约可以调用另一个可以调用另一个合约的合约，依此类推，但是这样一个执行链中的第一个合约将始终由EOA的交易调用。合约从不“自己运行”或“在后台运行”。合约实际上处于休眠状态，直到交易触发执行，直接或间接作为合约调用链的一部分。值得注意的是，智能合约在任何意义上都不是“并行”执行的 - 以太坊世界计算机可以被认为是单线程机器。
	
无论他们调用多少合约或这些合约在调用时做了什么，交易都是原子的。交易完整执行，只有在所有执行成功终止时，才会记录全局状态（合约，帐户等）中的任何更改。成功终止意味着程序在没有错误的情况下执行并且到达执行结束。如果执行因错误而失败，则其所有效果（状态更改）都被“回滚”，就像交易从未运行一样。失败的交易仍然记录为已经尝试过，并且用于执行的gas从发起账户中扣除，但是对合约或账户状态没有其他影响。

如前所述，重要的是要记住合约的代码不能更改。但是，可以“删除”合约，从其地址中删除代码及其内部状态（存储），留下一个空白帐户。在删除合约之后发送到该帐户地址的任何交易都不会导致任何代码执行，因为不再需要执行任何代码。要删除合约，你需要执行名为SELFDESTRUCT（以前称为SUICIDE）的EVM操作码。该操作花费“负gas”，即gas退还，从而激励删除存储状态从而释放网络客户端资源。以这种方式删除合约不会删除合约的交易历史（过去），因为区块链本身是不可变的。同样重要的是要注意，只有合约作者将智能合约编程为具有该功能时，才能使用SELFDESTRUCT功能。如果合约的代码没有SELFDESTRUCT操作码，或者无法访问，则无法删除智能合约。

[[high_level_languages]]
=== 介绍Ethereum高级语言

EVM是一个虚拟机，它运行一种特殊形式的代码，称为EVM字节码，与计算机的CPU类似，后者运行机器代码，如x86_64。我们将在<<evm_chapter>>中更详细地研究EVM的操作和语言。在本节中，我们将了解如何编写智能合约以在EVM上运行。

虽然可以直接在字节码中编写智能合约，但EVM字节码相当笨拙，而且程序员很难阅读和理解。相反，大多数以太坊开发人员使用高级语言编写程序，并使用编译器将它们转换为字节码。

虽然任何高级语言都可以适用于编写智能合约，但是将任意语言调整为可编译的EVM字节码是一项非常繁琐的工作，并且通常会导致一些混乱。智能合约在高度受限和简化的执行环境（EVM）中运行。此外，还需要一组特殊的EVM特定系统变量和函数。因此，从头开始构建智能合约语言比制作适合编写智能合约的通用语言更容易。结果，出现了许多用于编写智能合约的特殊用途语言。以太坊有几种这样的语言，以及生成EVM可执行字节码所需的编译器。

通常，编程语言可以分为两种广泛的编程范例：声明式和命令式，也分别称为函数式和过程式。在声明式编程中，我们编写表达程序逻辑的函数，而不是它的流程。声明式编程用于创建没有副作用的程序，这意味着函数外部的状态没有变化。声明式编程语言包括Haskell和SQL。相比之下，命令式编程是程序员编写一组结合了程序逻辑和流程的程序。命令式编程语言包括C ++和Java。有些语言是“混合的”，这意味着它们鼓励声明式编程，但也可用于表达命令式编程范例。这种混合语言包括Lisp，JavaScript和Python。通常，任何命令式语言都可以用于编写声明式范例，但它通常会导致不优雅的代码。相比之下，纯粹的声明式语言不能用于编写命令式范例。在纯粹的声明式语言中，没有“变量”。

虽然程序员更常使用命令式编程，但编写完全按预期执行的程序可能非常困难。程序的任何部分改变任何其他状态的能力使得很难推断程序的执行并引入许多bug机会。相比之下，声明式编程让人可以更容易理解程序的行为：由于它没有副作用，程序的任何部分都可以被孤立地理解。

在智能合约中，bug确实需要花费金钱。因此，编写没有意外影响的智能合约至关重要。为此，你必须能够清楚地了解程序的预期行为。因此，声明式语言在智能合约中的作用要大于在通用软件中的作用。然而，正如你将看到的，最广泛使用的智能合约语言（Solidity）势在必行。像大多数人一样，程序员拒绝变化！

目前支持的智能合约高级编程语言包括（按大致年龄排序）：

LLL:: 一种函数式（声明式）编程语言，具有类似Lisp的语法。这是以太坊智能合约的第一个高级语言，但今天很少使用。

Serpent:: 一种过程式（命令式）编程语言，其语法类似于Python。也可用于编写函数式（声明式）代码，尽管它并非完全没有副作用。

Solidity:: 一种过程式（命令式）编程语言，语法类似于JavaScript，C ++或Java。以太坊智能合约中最受欢迎和最常用的语言。

Vyper:: 一种最近开发的语言，类似于Serpent，同样使用类似Python的语法。旨在比Serpent更接近纯粹的函数式Python语言，而不是取代Serpent。

Bamboo:: 一种新开发的语言，受Erlang的影响，具有显式的状态转换，没有迭代流（循环）。旨在减少副作用并提高可审计性。非常新，但尚未被广泛采用。

如你所见，有许多语言可供选择。然而，在所有这些中，Solidity是迄今为止最受欢迎的，甚至是以太坊以及其他类似EVM的区块链的事实上的高级语言。我们将花费大部分时间使用Solidity，但也将探索其他高级语言中的一些示例，以了解其不同的哲学。

[[building_a_smart_contract_sec]]
=== 用Solidity构建智能合约

Solidity是由Gavin Wood（本书的合著者）创建的一种语言，明确用于编写具有直接支持在以太坊世界计算机的去中心化环境中执行的特性的智能合约。由此生成的属性非常普遍，因此最终被用于在其他几个区块链平台上编码智能合约。它由Christian Reitiwessner开发，然后由Alex Beregszaszi，Liana Husikyan，Yoichi Hirai和几位前以太坊核心贡献者开发。现在，Solidity作为一个独立的项目在 https://github.com/ethereum/solidity[on GitHub] 上被开发并维护。

Solidity项目的主要“产品”是Solidity编译器solc，它将用Solidity语言编写的程序转换为EVM字节码。该项目还管理以太坊智能合约的重要的应用程序二进制接口（application binary interface，ABI）标准，我们将在本章详细探讨。每个版本的Solidity编译器都对应并编译Solidity语言的特定版本。

首先，我们将下载Solidity编译器的二进制可执行文件。然后我们将开发并编译一个简单的合约，继续我们在<<intro_chapter>>中开始的例子。

==== 选择一个Solidity的版本

Solidity遵循称为语义版本控制 https://semver.org/[_semantic versioning_] 的版本控制模型，该模型指定版本号结构为由点分隔的三个数字：MAJOR.MINOR.PATCH。对于主要和向后不兼容的更改，“major”数字会递增，“minor”数字会在major版本之间添加向后兼容的功能时递增，并且“patch”编号会递增以用于向后兼容的bug修复。

在撰写本文时，Solidity的版本为0.4.24。major版本0的规则（用于项目的初始开发）是不同的：任何时候都可能发生任何变化。在实践中，Solidity将“minor”数字视为major版本，将“patch”数字视为minor版本。因此，在0.4.24中，4被认为是major版本，24被认为是minor版本。

Solidity的0.5 major版本即将发布。

正如你在<<intro_chapter>>中看到的，你的Solidity程序可以包含一个pragma指令，该指令指定与其兼容的Solidity的最小和最大版本，并可用于编译你的合约。

由于Solidity正在迅速发展，因此最新版本通常会更好。

==== 下载并安装

你可以使用许多方法来下载和安装Solidity，无论是作为二进制版本还是通过源代码编译。你可以在 https://solidity.readthedocs.io/en/latest/installing-solidity.html[the Solidity documentation] 中找到详细说明。

以下是使用apt包管理器在Ubuntu/Debian操作系统上安装Solidity的最新二进制版本的方法：

++++
<pre data-type="programlisting">
$ <strong>sudo add-apt-repository ppa:ethereum/ethereum</strong>
$ <strong>sudo apt update</strong>
$ <strong>sudo apt install solc</strong>
</pre>
++++

安装solc后，运行以下命令检查版本：

++++
<pre data-type="programlisting">
$ <strong>solc --version</strong>
solc, the solidity compiler commandline interface
Version: 0.4.24+commit.e67f0147.Linux.g++
</pre>
++++

根据你的操作系统和需求，还有许多其他方法可以安装Solidity，包括直接从源代码编译。有关更多信息，请参阅 https://github.com/ethereum/solidity[] 。



==== 开发环境

要在Solidity中开发，可以使用任何文本编辑器以及在命令行上使用solc。但是，你可能会发现一些为开发而设计的文本编辑器（如Emacs，Vim和Atom）提供了其他功能，如语法高亮和宏，使Solidity开发更容易。

还有基于Web的开发环境，例如 https://remix.ethereum.org/[Remix IDE] 和 https://ethfiddle.com/[EthFiddle] 。

使用高效的工具。最后，Solidity程序只是纯文本文件。虽然花哨的编辑器和开发环境可以使事情变得更容易，但你仅需要简单的文本编辑器，例如nano（Linux / Unix），TextEdit（macOS）甚至NotePad（Windows）。只需使用.sol扩展名保存程序源代码，它就会被Solidity编译器识别为Solidity程序。

==== 编写一个简单的Solidity程序

在<<intro_chapter>>中，我们编写了第一个Solidity程序。当我们第一次构建Faucet合约时，我们使用Remix IDE来编译和部署合约。在本节中，我们将重新审视，改进和修饰Faucet。

我们的第一次尝试看起来像<<original_sol_faucet>>。

[[original_sol_faucet]]
.Faucet.sol: A Solidity contract implementing a faucet
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet.sol[]
----
====

==== 使用Solidity Compiler（solc）进行编译

现在，我们将在命令行上使用Solidity编译器直接编译我们的合约。 Solidity编译器solc提供了各种选项，你可以通过传递--help参数来查看。

我们使用solc的--bin和--optimize参数来生成示例合约的优化的二进制文件：


++++
<pre data-type="programlisting">
$ <strong>solc --optimize --bin Faucet.sol</strong>
======= Faucet.sol:Faucet =======
Binary:
6060604052341561000f57600080fd5b60cf8061001d6000396000f300606060405260043610603e5
763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416
632e1a7d4d81146040575b005b3415604a57600080fd5b603e60043567016345785d8a00008111156
06357600080fd5b73ffffffffffffffffffffffffffffffffffffffff331681156108fc0282604051
600060405180830381858888f19350505050151560a057600080fd5b505600a165627a7a723058203
556d79355f2da19e773a9551e95f1ca7457f2b5fbbf4eacf7748ab59d2532130029
</pre>
++++


solc产生的结果是一个十六进制序列化的二进制文件，可以提交到以太坊区块链。

[[eth_contract_abi_sec]]
=== 以太坊合约ABI

在计算机软件中，应用程序二进制接口（application binary interface）是两个程序模块之间的接口;通常，在操作系统和用户程序之间。 ABI定义了如何在机器码中访问数据结构和函数;这不应与API混淆，后者将这种访问定义在高级的，通常是人类可读的格式中，比如源代码。因此，ABI是将数据编码进机器码以及从机器码解码的主要方式。

在以太坊中，ABI用于编码EVM的合约调用以及从交易中读取数据。 ABI的目的是定义可以调用的合约中的函数，并描述每个函数如何接受参数并返回其结果。

合约的ABI被指定为函数描述（参见Functions）和事件（参见Events）的JSON数组。函数描述是一个JSON对象，包含type，name，inputs，outputs，constant和payable等字段。事件描述对象具有type，name，inputs和anonymous等字段。

我们使用solc命令行Solidity编译器为我们的Faucet.sol示例合约生成ABI：

++++
<pre data-type="programlisting">
$ <strong>solc --abi Faucet.sol</strong>
======= Faucet.sol:Faucet =======
Contract JSON ABI
[{"constant":false,"inputs":[{"name":"withdraw_amount","type":"uint256"}], \
"name":"withdraw","outputs":[],"payable":false,"stateMutability":"nonpayable", \
"type":"function"},{"payable":true,"stateMutability":"payable", \
"type":"fallback"}]
</pre>
++++

如你所见，编译器生成了一个JSON数组，描述由Faucet.sol定义的两个函数。任何想要在部署后访问Faucet合约的应用程序都可以使用这个JSON。使用ABI，诸如钱包或DApp浏览器之类的应用程序可以构造使用正确的参数和参数类型调用Faucet中的函数的交易。例如，钱包会知道要调用函数withdraw，它必须提供名为withdraw_amount的uint256类型的参数。钱包可以提示用户提供该值，然后创建对其进行编码的交易并执行withdraw函数。

应用程序与合约交互所需的只是ABI和已部署合约的地址。

[[solidity_pragma]]
==== 选择Solidity编译器和语言版本

正如我们在前面的代码中看到的那样，我们的Faucet合约用Solidity版本0.4.21成功被编译。但是，如果我们使用了不同版本的Solidity编译器呢？语言仍在不断变化，事情可能会以意想不到的方式发生变化。我们的合约相当简单，但如果我们的程序使用仅在Solidity版本0.4.19中添加的特性并且我们尝试使用0.4.18编译它会怎样？

为解决此类问题，Solidity提供了一个称为版本编译指示（version pragma）的编译器指令，它指示编译器，程序需要特定的编译器（和语言）版本。我们来看一个例子：

[[compiler_version]]
----
pragma solidity ^0.4.19;
----

Solidity编译器读取版本编译指示，如果编译器版本与版本编译指示不兼容，将产生错误。在这个例子中，我们的版本编译指示说这个程序可以由最小版本为0.4.19的Solidity编译器编译。但是，符号^表示我们允许用任何高于0.4.19的minor修订进行编译;例如，0.4.20，但不能是0.5.0（这是一个major修订，而不是minor修订）。 Pragma指令不会编译为EVM字节码。它们仅供编译器用于检查兼容性。

让我们为我们的Faucet合约添加一个pragma指令。我们将新文件命名为Faucet2.sol，以便在我们从Faucet2.sol开始执行这些示例时跟踪我们的更改：<<add_pragma_to_faucet>>。

[[add_pragma_to_faucet]]
.Faucet2.sol: Adding the version pragma to Faucet
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet2.sol[]
----
====

添加版本编译指示是最佳实践，因为它避免了编译器和语言版本不匹配的问题。我们将探讨其他最佳实践，并在本章中继续改进Faucet合约。

=== 用Solidity编程

在本节中，我们将介绍Solidity语言的一些功能。正如我们在<<intro_chapter>>中提到的，我们的第一个合约示例非常简单，并且在各方面都存在缺陷。我们将在这里逐步改进它，同时探索如何使用Solidity。然而，这不是一个全面的Solidity教程，因为Solidity非常复杂且正在快速发展。我们将介绍基础知识，并为你提供足够的基础，以便你可以自己探索其余部分。 Solidity的文档可以在 https://solidity.readthedocs.io/en/latest/[on the project website] 找到。

==== 数据类型

首先，让我们看一下Solidity中提供的一些基本数据类型：

Boolean (+bool+):: 布尔值，true或false，带逻辑运算符！ （否），&&（与），|| （或），==（等于），和！=（不等于）。

Integer (+int+, +uint+):: 有符号（int）和无符号（uint）整数，以从int8到uint256的8位增量声明。如果没有大小后缀，则使用256位，以匹配EVM的字长。

Fixed point (+fixed+, +ufixed+):: 定点数，用(u)fixedMxN声明，其中M是以位为单位的大小（增量为8，直到256），N是该点之后的小数位数（最多18位）;例如，ufixed32x2。

Address:: 一个20字节的以太坊地址。地址对象有许多有用的成员函数，主要是balance（返回帐户余额）和transfer（将以太币转移到帐户）。

Byte array (fixed):: 固定大小的字节数组，用bytes1到bytes32声明。

Byte array (dynamic):: 可变大小的字节数组，用bytes或string声明。

Enum:: 用于枚举离散值的用户定义类型：枚举NAME {LABEL1, LABEL 2, ...}。

Arrays:: 任何类型的数组，无论是固定的还是动态的：uint32[][5]是一个固定大小的数组，由五个无符号整数的动态数组组成。

Struct:: 用于对变量进行分组的用户定义数据容器：struct NAME {TYPE1 VARIABLE1; TYPE2 VARIABLE2; ...}。

Mapping:: 键值对的哈希查找表：mapping(KEY_TYPE => VALUE_TYPE) NAME。

除了这些数据类型，Solidity还提供了各种可用于计算不同单位的价值字面量：

Time units:: 单位seconds, minutes, hours, 和 days可以用作后缀，转换为基本单位秒的倍数。

Ether units:: wei，finney，szabo和ether单位可以用作后缀，转换为基本单位wei的倍数。

在我们的Faucet合约示例中，我们对withdraw_amount变量使用了uint（uint256的别名）。我们还间接使用了一个地址变量，我们用msg.sender设置了它。在本章的其余部分中，我们将在示例中使用更多这些数据类型。

让我们使用其中一个单位乘数来提高示例合约的可读性。在withdraw函数中，我们限制最大提取额，表示ether的基本单位wei的限制：

----
require(withdraw_amount <= 100000000000000000);
----

这不是很容易阅读。我们可以通过使用单位乘数ether来改进我们的代码，用ether而不是wei表示值：

----
require(withdraw_amount <= 0.1 ether);
----

==== 预定义的全局变量和函数

在EVM中执行合约时，它可以访问一小组全局对象。这些包括block，msg和tx对象。此外，Solidity将许多EVM操作码公开为预定义函数。在本节中，我们将学习你可以在Solidity中的智能合约中访问的变量和函数。

===== 交易/消息调用上下文

msg对象是启动此合约执行的交易调用（EOA发起）或消息调用（合约发起）。它包含许多有用的属性：

+msg.sender+:: 我们已经使用过这个属性了。它表示发起此合约调用的地址，不一定是发送交易的原始EOA。如果我们的合约是由EOA交易直接调用的，那么这是签署交易的地址，否则它将是合约地址。

+msg.value+:: 通过此调用发送的ether的值（以wei计价）。

+msg.gas+:: 此执行环境的gas供应中剩余的gas量。这在Solidity v0.4.21中已弃用，并由gasleft函数取代。

+msg.data+:: 此调用到我们合约中的数据有效负载。

+msg.sig+:: 数据有效负载的前四个字节，即函数选择器。

[NOTE]
====
每当合约调用另一个合约时，msg的所有属性的值都会更改以反映新调用者的信息。唯一的例外是delegatecall函数，它在原始msg上下文中运行另一个合约/库的代码。
====

===== 交易上下文

tx对象提供了一种访问与交易相关的信息的方法：

++tx.gasprice++:: 调用交易中的gas价格。

++tx.origin++:: 此交易的原始EOA的地址。警告：不安全！

===== 区块上下文

block对象包含有关当前区块的信息：

++block.blockhash(__blockNumber__)++:: 指定区块号的区块哈希，只能查到过去最多256个区块。已弃用并替换为Solidity v0.4.22中的blockhash函数。

++block.coinbase++:: 当前区块的费用和区块奖励的接收者地址。

++block.difficulty++:: 当前区块的难度（工作量证明）。

++block.gaslimit++:: 可以在当前区块中包含的所有交易中花费的最大gas量。

++block.number++:: 当前区块编号（区块链高度）。

++block.timestamp++:: 矿工放置在当前区块中的时间戳（自Unix epoch以来的秒数）。

[[solidity_address_object]]
===== 地址对象

任何地址，无论是作为输入传递还是从合约对象转换，都有许多属性和方法：

+address.balance+:: 地址的余额，以wei为单位。例如，当前合约余额是地址address(this).balance。

++address.transfer(__amount__)++:: 将金额（以wei为单位）转移到此地址，有任何错误的话抛出异常。我们在我们的Faucet示例中使用此函数作为msg.sender地址上的方法，即msg.sender.transfer。

++address.send(__amount__)++:: 与transfer类似，只是它不抛出异常，而是在出错时返回false。警告：始终检查send的返回值。

++address.call(__payload__)++:: 低级CALL函数 - 可以使用数据有效负载构造任意消息调用。错误时返回false。警告：不安全------接收者可能（意外或恶意）用尽所有gas，导致合约因OOG异常而停止;总是检查call的返回值。

++address.callcode(__payload__)++:: 低级CALLCODE函数，和地址address(this).call(...)类似，但此合约的代码替换为地址的代码。错误时返回false。警告：仅限高级使用！

+address.delegatecall()+:: 低级DELEGATECALL函数，和callcode(...)类似，但具有当前合约所见（知道）的完整msg上下文。错误时返回false。警告：仅限高级使用！

===== 内建函数

其他值得注意的函数是：

+addmod+, +mulmod+:: 用于模加法和乘法。例如，addmod(x,y,k)计算(x + y) % k。

+keccak256+, +sha256+, +sha3+, +ripemd160+:: 使用各种标准哈希算法计算哈希值的函数。

+ecrecover+:: 恢复用于签名消息的地址。

++selfdestrunct(__recipient_address__)++:: 删除当前合约，将帐户中任何剩余的ether发送到接收者地址。

+this+:: 当前正在执行的合约帐户的地址。

==== 合约定义

Solidity的主要数据类型是合约;我们的Faucet示例只是定义了一个contract对象。与面向对象语言中的任何对象类似，合约（contract）是包含数据和方法的容器。

Solidity提供了另外两种类似于合约（contract）的对象类型：

+interface+:: 接口定义的结构与合约完全相同，除了没有定义任何函数，它们仅被声明。这种类型的声明通常称为stub;它告诉你函数的参数和返回类型，但没有任何实现。接口指定合约的“模型”;在继承时，接口声明的每个函数都必须由子合约定义。

+library+:: 库合约是指仅部署一次并由其他合约使用delegatecall方法调用的合约（请参阅address object）。

[[solidity_functions]]
==== 函数

在合约中，我们定义可以由EOA交易或另一个合约调用的函数。在我们的Faucet示例中，我们有两个函数：withdraw和（未命名的）fallback函数。

我们用于在Solidity中声明函数的语法如下：

++++
<pre data-type="programlisting">
function FunctionName([<em>parameters</em>]) {public|private|internal|external}
[pure|constant|view|payable] [<em>modifiers</em>] [returns (<em>return types</em>)]
</pre>
++++


让我们看看每个部分：

++FunctionName++:: 函数的名称，用于在交易（来自EOA），从另一个合约或甚至从同一合约中调用函数。每个合约中的一个函数可以在没有名称的情况下定义，在这种情况下，它是fallback函数，在没有命名其他函数时调用。fallback函数不能有任何参数或返回任何内容。

__++parameters++__:: 在名称后面，我们指定必须传递给函数的参数，包括其名称和类型。在我们的Faucet示例中，我们将uint withdraw_amount定义为withdraw函数的唯一参数。

下一组关键字（public, private, internal, external）指定函数的可见性：

+public+:: public是默认的;这种函数可以由其他合约或EOA交易调用，也可以从合约内调用。在我们的Faucet示例中，两个函数都定义为public。

+external+:: external函数类似于public函数，但它们不能从合约内调用，除非明确地以关键字this为前缀。

+internal+:: internal函数只能从合约内访问 - 它们不能被另一个合约或EOA交易调用。它们可以被派生合约（继承了当前合约）调用。

+private+:: private函数类似于internal函数，但不能由派生合约调用。

请记住，internal和private这两个词有些误导。合约中的任何函数或数据始终在公共区块链上可见，这意味着任何人都可以看到代码或数据。此处描述的关键字仅影响函数的调用方式和调用时间。

第二组关键字（pure, constant, view, payable）会影响函数的行为：

+constant+ or +view+:: 标记为view的函数承诺不修改任何状态。术语constant是view的别名，将在以后的版本中弃用。此时，编译器不会强制执行view修饰符，只会产生警告，但这将成为Solidity v0.5中的强制关键字。

+pure+:: pure函数既不读取也不写入存储（storage）中的任何变量。它只能操作参数和返回数据，而不引用任何存储的数据。pure函数旨在鼓励声明式编程，没有副作用或状态。

+payable+:: payable函数是可以接收传入支付（付款）的函数。未声明为payable的函数将拒绝传入支付。由于EVM中的设计决策，有两个例外：即使fallback函数未被声明为payable，coinbase支付和SELFDESTRUCT继承也将被支付，但这是有道理的，因为代码执行不是这种支付的一部分。

正如你在我们的Faucet示例中所看到的，我们有一个payable函数（fallback函数），这是唯一可以接收传入支付的函数。

==== 合约构造函数和selfdestruct

有一个特殊函数只使用一次。创建合约时，如果构造函数存在，它还会运行构造函数，以初始化合约的状态。构造函数在与创建合约相同的交易中运行。构造函数是可选的;你会注意到我们的Faucet示例没有构造函数。

构造函数可以通过两种方式指定。直到Solidity v0.4.21，构造函数是一个名称与合约名称相匹配的函数，如下所示：

[source,solidity]
----
contract MEContract {
	function MEContract() {
		// This is the constructor
	}
}
----


这种格式的难点在于，如果更改了合约名称并且未更改构造函数名称，则它不再是构造函数。同样，如果在合约和/或构造函数的命名中存在意外拼写错误，则该函数也不再是构造函数。这可能会导致一些非常讨厌，意想不到的和难以发现的bug。想象一下，例如，如果构造函数为了控制目的而设置合约的所有者。如果由于命名错误而该函数实际上不是构造函数，则不仅在创建合约时将所有者保留为未设置，而且该函数也可能被部署为合约的永久的和“可调用”的部分，像正常函数一样，允许任何第三方劫持合约，并在合约创建后成为“所有者”。

为了解决构造函数基于具有与合约相同的名称的潜在问题，Solidity v0.4.22引入了一个constructor关键字，其运行类似于构造函数但没有名称。重命名合约根本不会影响构造函数。此外，更容易识别哪个函数是构造函数。它看起来像这样：

[source,solidity]
----
pragma ^0.4.22
contract MEContract {
	constructor () {
		// This is the constructor
	}
}
----

总而言之，合约的生命周期始于从EOA或合约账户的创建交易。如果存在构造函数，则它将作为合约创建的一部分执行，以在创建合约时初始化合约的状态，然后将其丢弃。

合约生命周期的另一端是合约析构（destruction）。合约被称为SELFDESTRUCT的特殊EVM操作码破坏。它曾经被称为SUICIDE，但由于该词的负面影响，该名称已被弃用。在Solidity中，此操作码作为高级内建函数公开，称为selfdestruct，它接受一个参数：接收合约帐户中剩余的所有ether余额的地址。它看起来像这样：

[source,solidity]
----
selfdestruct(address recipient);
----

请注意，如果你希望合约可以被删除，则必须将此命令显式添加到合约中 - 这是删除合约的唯一方法，默认情况下它不存在。通过这种方式，可能依赖一个合约永远存在的合约的用户可以确定如果合约不包含SELFDESTRUCT操作码，则合约不能被删除。

==== 添加构造函数和selfdestruct到我们的Faucet示例

我们在<<intro_chapter>>中介绍的Faucet示例合约没有任何构造函数或selfdestruct函数。这是一个无法删除的永恒合约。让我们通过添加构造函数和selfdestruct函数来改变它。我们可能希望selfdestruct只能由最初创建合约的EOA调用。按照惯例，这通常存储在名为owner的地址变量中。我们的构造函数设置owner变量，selfdestruct函数将首先检查是否是owner直接调用它。

首先，我们的构造函数：

[source,solidity]
----
// Version of Solidity compiler this program was written for
pragma solidity ^0.4.22;

// Our first contract is a faucet!
contract Faucet {

	address owner;

	// Initialize Faucet contract: set owner
	constructor() {
		owner = msg.sender;
	}

[...]
----

我们已经修改了pragma指令，将v0.4.22指定为此示例的最小版本，因为我们使用了Solidity v0.4.22中引入的新constructor关键字。我们的合约现在有一个名为owner的地址类型变量。 “owner”这个名称在任何方面都不特别。我们可以将此地址变量称为“potato”，并仍以相同的方式使用它。名称owner只是明确了其目的。

接下来，我们的构造函数作为合约创建交易的一部分运行，将msg.sender中的地址分配给owner变量。我们在withdraw函数中使用msg.sender来识别提款请求的发起人。但是，在构造函数中，msg.sender是发起合约创建的EOA或合约地址。我们知道这是因为这是一个构造函数：它只在合约创建期间运行一次。

现在我们可以添加一个函数来销毁合约。我们需要确保只有owner才能运行此函数，因此我们将使用require语句来控制访问。以下是这个函数的样子：

[source,solidity]
----
// Contract destructor
function destroy() public {
	require(msg.sender == owner);
	selfdestruct(owner);
}
----

如果有人从除了owner之外的地址调用此destroy函数，它将失败。但是，如果构造函数存储在owner中的相同地址调用它，则合约将自我销毁并将所有剩余余额发送到owner地址。请注意，我们没有使用不安全的tx.origin来确定owner是否希望销毁合约 - 使用tx.orgin会允许恶意合约在未经你许可的情况下销毁你的合约。

==== 函数修饰符

Solidity提供了一种称为函数修饰符的特殊函数。通过在函数声明中添加修饰符名称，可以将修饰符应用于函数。修饰符通常用于创建适用于合约中许多函数的条件。我们的destroy函数中已经有了一个访问控制语句。让我们创建一个表达该条件的函数修饰符：

[source,solidity]
----
modifier onlyOwner {
    require(msg.sender == owner);
    _;
}
----


此函数修饰符（名为onlyOwner）在其修饰的任何函数上设置条件，要求存储为合约所有者的地址与交易的msg.sender的地址相同。这是访问控制的基本设计模式，只允许合约所有者执行具有onlyOwner修饰符的任何函数。

你可能已经注意到我们的函数修饰符里面有一个特殊的句法“占位符”，一个下划线后跟一个分号（&#95;;）。此占位符由正在被修饰的函数的代码替换。本质上，修饰符“包裹”被修饰的函数，将其代码放在由下划线字符标识的位置。

要应用修饰符，请将其名称添加到函数声明中。可以将多个修饰符应用于函数;它们作为以逗号分隔的列表，以声明的顺序应用。

让我们重写我们的destroy函数以使用onlyOwner修饰符：

[source,solidity]
----
function destroy() public onlyOwner {
    selfdestruct(owner);
}
----

函数修饰符的名称（onlyOwner）位于关键字public之后，告诉我们destroy函数被onlyOwner修饰符修饰。从本质上讲，你可以将其视为“只有owner可以销毁此合约”。在实践中，生成的代码相当于用来自onlyOwner的代码“包裹”destroy的代码。

函数修饰符是一个非常有用的工具，因为它们允许我们为函数编写前置条件并一致地应用它们，使代码更易于阅读，因此更容易审计安全性。它们最常用于访问控制，但它们非常通用，可用于各种其他目的。

在修饰符中，你可以访问被修饰的函数可见的所有值（变量和参数）。在这种情况下，我们可以访问在合约中声明的owner变量。但是，反之则不行：你无法在被修饰的函数中访问任何修饰符变量。

==== 合约继承

Solidity的合约对象支持继承，继承是一种用附加功能扩展基础合约的机制。要使用继承，使用关键字is指定父合约：

[source,solidity]
----
contract Child is Parent {
  ...
}
----

使用此构造，Child合约继承Parent的所有方法，功能和变量。 Solidity还支持多重继承，可以在is关键字后使用逗号分隔的合约名称指定：

[source,solidity]
----
contract Child is Parent1, Parent2 {
  ...
}
----

合约继承允许我们以实现模块化，可扩展性和重用的方式编写合约。我们从简单的合约开始，实现最通用的功能，然后通过在更专业的合约中继承这些功能来扩展它们。

在我们的Faucet合约中，我们介绍了构造函数和析构函数，以及在构造时指定的owner的访问控制。这些功能非常通用：很多合约都有它们。我们可以将它们定义为通用合约，然后使用继承将它们扩展到Faucet合约。

我们首先定义一个基础合约owned，它有一个owner变量，在合约的构造函数中设置它：

[source,solidity]
----
contract owned {
	address owner;

	// Contract constructor: set owner
	constructor() {
		owner = msg.sender;
	}

	// Access control modifier
	modifier onlyOwner {
	    require(msg.sender == owner);
	    _;
	}
}
----

接下来，我们定义一个基础合约mortal，它继承了owned：

[source,solidity]
----
contract mortal is owned {
	// Contract destructor
	function destroy() public onlyOwner {
		selfdestruct(owner);
	}
}
----

正如你所看到的，mortal合约可以使用在owned中定义的onlyOwner函数修饰符。它间接地还使用owner地址变量和定义在owned中的构造函数。继承使每个合约更简单，并专注于其特定功能，允许我们以模块化方式管理细节。

现在我们可以进一步扩展owned合约，在Faucet中继承其能力：

[source,solidity]
----
contract Faucet is mortal {
    // Give out ether to anyone who asks
    function withdraw(uint withdraw_amount) public {
        // Limit withdrawal amount
        require(withdraw_amount <= 0.1 ether);
        // Send the amount to the address that requested it
        msg.sender.transfer(withdraw_amount);
    }
    // Accept any incoming amount
    function () public payable {}
}
----

通过继承mortal，而mortal继承owned，Faucet合约现在具有构造函数和销毁函数，以及一个已定义的owner。功能与把这些功能都定义在Faucet中的效果相同，但现在我们可以在其他合约中重用这些功能而无需再次编写。代码重用和模块化使我们的代码更清晰，更易于阅读，更易于审计。

==== 错误处理（assert, require, revert）

合约调用可以终止并返回错误。 Solidity中的错误处理由四个函数处理：assert，require，revert和throw（现已弃用）。

当合约以错误终止时，如果调用了多个合约，则所有状态更改（变量，余额等的更改）都会被恢复，从而一直到整个合约链。这可以确保交易是原子的，这意味着它们要么成功完成，要么对状态没有影响，并且完全被恢复。

assert和require函数以相同的方式运行，评估条件并在条件为假时用一个错误停止执行。按照惯例，当结果预期为真时使用assert，这意味着我们使用assert来测试内部条件。相比之下，在测试输入（例如函数参数或交易字段）时使用require，设置我们对这些条件的期望。

我们在函数修饰符onlyOwner中使用了require来测试消息发送者是合约的所有者：

[source,solidity]
----
require(msg.sender == owner);
----

require函数充当门控条件，阻止执行函数的其余部分并在不满足时产生错误。

从Solidity v0.4.22开始，require还可以包含一条有用的文本消息，可用于显示错误原因。错误消息记录在交易日志中。因此，我们可以通过在require函数中添加错误消息来改进我们的代码：

[source,solidity]
----
require(msg.sender == owner, "Only the contract owner can call this function");
----

revert和throw函数会停止合约的执行并恢复任何状态更改。 throw函数已过时，将在未来的Solidity版本中删除;你应该使用revert。revert函数还可以将错误消息作为唯一参数，该参数记录在交易日志中。

合约中的某些条件会产生错误，无论我们是否明确检查它们。例如，在我们的Faucet合约中，我们不会检查是否有足够的ether以满足提款请求。这是因为transfer函数会因错误而失败，如果余额不足，则还原交易：

[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

但是，最好明确检查并在失败时提供明确的错误消息。我们可以通过在transfer之前添加require语句来做到这一点：

[source,solidity]
----
require(this.balance >= withdraw_amount,
	"Insufficient balance in faucet for withdrawal request");
msg.sender.transfer(withdraw_amount);
----

像这样的附加错误检查代码会略微增加gas消耗，但它提供的错误报告比被省略的更好。你需要根据合约的预期用途在gas消耗和详细错误检查之间找到适当的平衡点。如果是针对测试网的Faucet合约，我们可能会增加错误的额外报告，即使它需要更多的gas。也许对于主网合约，我们的gas使用会更加节约。

[[solidity_events]]
==== 事件（Events）

当交易完成（无论成功与否）时，它会产生交易收据（transaction receipt），我们将在<<evm_chapter>>中看到。交易收据包含日志条目，这些日志条目提供有关在执行交易期间发生的操作的信息。事件（Events）是用于构造这些日志的Solidity高级对象。

事件对轻客户端和DApp服务特别有用，轻客户端和DApp服务可以“监视”特定事件并将其报告给用户界面(UI)，或者更改应用程序的状态以反映底层合约中的事件。

事件对象接受序列化并记录在区块链中的交易日志中的参数。你可以在参数之前提供关键字indexed，以使值成为可由应用程序搜索或过滤的索引表（哈希表）的一部分。

到目前为止，我们还没有在我们的Faucet示例中添加任何事件，所以让我们这样做。我们将添加两个事件，一个用于记录任何提款，另一个用于记录任何存款。我们将分别称这两种事件为Withdrawal和Deposit。首先，我们定义Faucet合约中的事件：

[source,solidity]
----
contract Faucet is mortal {
	event Withdrawal(address indexed to, uint amount);
	event Deposit(address indexed from, uint amount);

	[...]
}
----

我们选择将地址索引，以允许在任何用于访问我们的Faucet的用户界面（UI）中进行搜索和过滤。

接下来，我们使用emit关键字将事件（event）数据合并到交易日志中：

[source,solidity]
----
// Give out ether to anyone who asks
function withdraw(uint withdraw_amount) public {
    [...]
    msg.sender.transfer(withdraw_amount);
    emit Withdrawal(msg.sender, withdraw_amount);
}
// Accept any incoming amount
function () public payable {
    emit Deposit(msg.sender, msg.value);
}
----

由此产生的Faucet.sol合约看起来像<<Faucet8_sol>>。

[[Faucet8_sol]]
.Faucet8.sol: Revised Faucet contract, with events
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet8.sol[]
----
====

===== 捕获事件

好的，我们已经设置合约来发出事件。我们如何查看交易结果并“捕获”事件？ web3.js库提供包含交易日志的数据结构。在那些数据结构里我们可以看到交易生成的事件。

让我们使用truffle在改进后的Faucet合约上运行测试交易。按照<<truffle>>中的说明设置一个项目（project）目录并编译Faucet代码。源代码可以在 https://github.com/ethereumbook/ethereumbook[the book's GitHub repository] 里的code/truffle/FaucetEvents目录下找到。

++++
<pre data-type="programlisting">
$ <strong>truffle develop</strong>
truffle(develop)> <strong>compile</strong>
truffle(develop)> <strong>migrate</strong>
Using network 'develop'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0xb77ceae7c3f5afb7fbe3a6c5974d352aa844f53f955ee7d707ef6f3f8e6b4e61
  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0
Saving successful migration to network...
  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Deploying Faucet...
  ... 0xfa850d754314c3fb83f43ca1fa6ee20bc9652d891c00a2f63fd43ab5bfb0d781
  Faucet: 0x345ca3e014aaf5dca488057592ee47305d9b3e10
Saving successful migration to network...
  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0
Saving artifacts...

truffle(develop)> <strong>Faucet.deployed().then(i => {FaucetDeployed = i})</strong>
truffle(develop)> <strong>FaucetDeployed.send(web3.toWei(1, "ether")).then(res => \
                  { console.log(res.logs[0].event, res.logs[0].args) })</strong>
Deposit { from: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 18, c: [ 10000 ] } }
truffle(develop)> <strong>FaucetDeployed.withdraw(web3.toWei(0.1, "ether")).then(res => \
                  { console.log(res.logs[0].event, res.logs[0].args) })</strong>
Withdrawal { to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 17, c: [ 1000 ] } }
</pre>
++++

使用deployed函数部署合约后，我们执行了两笔交易。第一笔交易是存款（使用send），在交易日志中发出Deposit事件：

----
Deposit { from: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 18, c: [ 10000 ] } }
----

接下来，我们使用withdraw函数进行提款。这会发出Withdrawal事件：

----
Withdrawal { to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 17, c: [ 1000 ] } }
----

为了获得这些事件，我们来查看作为交易结果（res）返回的logs数组。第一个日志条目（logs[0]）包含logs[0].event中的事件名称和logs[0].args中的事件参数。通过在控制台上显示这些，我们可以看到发出的事件名称和事件参数。

事件是一种非常有用的机制，不仅用于合约内通信，还用于开发期间的调试。

==== 调用其他合约（send, call, callcode, delegatecall）

从合约中调用其他合约是非常有用但有潜在危险的操作。我们将研究实现这一目标的各种方法，并评估每种方法的风险。简而言之，风险源于这样一个事实，即你可能对你正在调用的合约或调用你合约的合约知之甚少。在编写智能合约时，你必须记住，虽然你可能主要希望与EOAs打交道，但没有什么可以阻止任意复杂的，也许是恶意的合约调用你的代码或者被你的代码调用。

===== 创建一个新实例

调用另一个合约的最安全方式是你自己创建其他合约。这样，你就可以确定其接口和行为。为此，你可以使用关键字new来简单地实例化它，就像在其他面向对象的语言中一样。在Solidity中，关键字new将在区块链上创建合约并返回可用于引用它的对象。假设你想在另一个名为Token的合约中创建并调用Faucet合约：

[source,solidity]
----
contract Token is mortal {
	Faucet _faucet;

	constructor() {
		_faucet = new Faucet();
	}
}
----

这种合约构造机制可确保你了解合约的确切类型及其接口。合约Faucet必须在Token的范围内定义，如果定义在另一个文件中，你可以使用import语句：

[source,solidity]
----
import "Faucet.sol";

contract Token is mortal {
	Faucet _faucet;

	constructor() {
		_faucet = new Faucet();
	}
}
----

你可以选择在创建时指定ether transfer的值，并将参数传递给新合约的构造函数：

[source,solidity]
----
import "Faucet.sol";

contract Token is mortal {
	Faucet _faucet;

	constructor() {
		_faucet = (new Faucet).value(0.5 ether)();
	}
}
----

你也可以调用Faucet的函数。在这个例子中，我们从Token的destroy函数中调用Faucet的destroy函数：

[source,solidity]
----
import "Faucet.sol";

contract Token is mortal {
	Faucet _faucet;

	constructor() {
		_faucet = (new Faucet).value(0.5 ether)();
	}

	function destroy() ownerOnly {
		_faucet.destroy();
	}
}
----

请注意，虽然你是Token合约的所有者，但Token合约本身拥有新的Faucet合约，因此只有Token合约才能销毁它。

===== 寻址现有实例

调用合约的另一种方法是转换现有合约实例的地址。使用此方法，可以将已知接口应用于现有实例。因此，至关重要的是，你能肯定你正在寻址的实例实际上是你所假设的类型。我们来看一个例子：

[source,solidity]
----
import "Faucet.sol";

contract Token is mortal {

	Faucet _faucet;

	constructor(address _f) {
		_faucet = Faucet(_f);
		_faucet.withdraw(0.1 ether)
	}
}
----

在这里，我们将一个地址作为参数提供给构造函数，_f，然后将它转换为Faucet对象。这比之前介绍的机制风险更大，因为我们不能确定该地址是否实际上是Faucet对象。当我们调用withdraw时，我们假设它接受相同的参数并执行与我们的Faucet声明相同的代码，但我们无法确定。正如我们所知，这个地址的withdraw函数可以执行与我们预期完全不同的东西，即使它命名相同。因此，使用作为输入传递的地址并将它们转换为特定对象比自己创建合约更危险。

===== 原始call, delegatecall

Solidity为调用其他合约提供了一些更“低级”的函数。这些函数直接对应于同名的EVM操作码，并允许我们手动构建合约到合约的调用。因此，它们代表了调用其他合约的最灵活和最危险的机制。

以下是使用call方法的相同示例：

[source,solidity]
----
contract Token is mortal {
	constructor(address _faucet) {
		_faucet.call("withdraw", 0.1 ether);
	}
}
----

正如你所看到的，这种类型的调用是对函数的盲目调用（blind call），非常类似于仅从合约的上下文中构建原始交易。它能使你的合约暴露于许多安全风险，最重要的是可重入（reentrancy），我们将在<<reentrancy_security>>中更详细地讨论。如果出现问题，call函数将返回false，因此你可以评估返回值以进行错误处理：

[source,solidity]
----
contract Token is mortal {
	constructor(address _faucet) {
		if !(_faucet.call("withdraw", 0.1 ether)) {
			revert("Withdrawal from faucet failed");
		}
	}
}
----

另一种调用方式是delegatecall，它取代了更危险的callcode。 callcode方法很快就会被弃用，所以不应该使用它。

如<<solidity_address_object>>中所述，delegatecall与call的不同之处在于msg上下文不会更改。例如，虽然call将msg.sender的值更改为调用合约，但delegatecall保持与调用合约中相同的msg.sender。从本质上讲，delegatecall在当前合约的执行上下文中运行另一个合约的代码。它最常被用于调用库（library）中的代码。它还允许你使用存储在其他位置的库函数的模式，但使库函数代码与合约的存储数据一起使用。

应谨慎使用delegatecall。它可能会产生一些意想不到的效果，特别是如果你调用的合约没有被设计为库。

让我们使用一个示例合约来演示call和delegatecall用于调用库和合约的各种调用语义。在<<call_examples_code>>中：我们使用一个事件来记录每个调用的详细信息，并根据调用类型查看调用上下文的变化情况。

[[call_examples_code]]
.CallExamples.sol: An example of different call semantics
====
[source,solidity,linenums]
----
include::code/truffle/CallExamples/contracts/CallExamples.sol[]
----
====

正如你在此示例中所看到的，我们的主要合约是caller，它调用名为calledLibrary的库和名为calledContract的合约。被调用的库和合约都有相同的calledFunction函数，函数发出一个名为calledEvent的事件。名为calledEvent的事件记录了三个数据：msg.sender，tx.origin和this。每次调用calledFunction时，它都可能具有不同的执行上下文（可能具有所有上下文变量的不同值），具体取决于是直接调用还是通过delegatecall调用。

在caller中，我们首先通过调用calledFunction来直接调用合约和库。然后，我们显式地使用低级函数call和delegatecall来调用calledContract.calledFunction。通过这种方式，我们可以看到各种调用机制的行为方式。

让我们在Truffle开发环境中运行它并捕获事件，看看效果如何：

++++
<pre data-type="programlisting">
truffle(develop)> <strong>migrate</strong>
Using network 'develop'.
[...]
Saving artifacts...
truffle(develop)> <strong>web3.eth.accounts[0]</strong>
'0x627306090abab3a6e1400e9345bc60c78a8bef57'
truffle(develop)> <strong>caller.address</strong>
'0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f'
truffle(develop)> <strong>calledContract.address</strong>
'0x345ca3e014aaf5dca488057592ee47305d9b3e10'
truffle(develop)> <strong>calledLibrary.address</strong>
'0xf25186b5081ff5ce73482ad761db0eb0d25abfbf'
truffle(develop)> <strong>caller.deployed().then( i => { callerDeployed = i })</strong>

truffle(develop)> <strong>callerDeployed.make_calls(calledContract.address).then(res => \
                  { res.logs.forEach( log => { console.log(log.args) })})</strong>strong>
{ sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10' }
{ sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f' }
{ sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10' }
{ sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f' }
</pre>
++++

让我们看看这里发生了什么。我们调用了make_calls函数并传递了calledContract的地址，然后捕获了每个不同调用发出的四个事件。让我们看看make_calls函数并走完每一步。

第一个调用是：

----
_calledContract.calledFunction();
----

在这里，我们直接调用calledContract.calledFunction，使用calledFunction的高级ABI。发出的事件是：

----
sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10'
----

如你所见，msg.sender是caller合约的地址。 tx.origin是我们的帐户web3.eth.accounts [0]的地址，它将交易发送给caller。事件由calledContract发出，我们可以从事件的最后一个参数中看到。

make_calls中的下一个调用是调用库：

----
calledLibrary.calledFunction();
----

它看起来与我们调用合约的方式相同，但行为却截然不同。让我们看看发出的第二个事件：

----
sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f'
----

这次，msg.sender不是caller的地址。相反，它是我们帐户的地址，与交易起源（transaction origin）相同。那是因为当你调用一个库时，调用总是delegatecall并在caller的上下文中运行。因此，当被调用的库代码运行时，它继承了caller的执行上下文，就好像它的代码在caller内部运行一样。变量this（显示在发出的事件中）是caller的地址，即使它是从被调用的calledLibrary库中访问的。

接下来的两个调用，使用低级call和delegatecall，验证我们的期望，发出的事件反映了我们刚才看到的情况。

[[gas_sec]]
=== Gas考虑因素

在<<gas>>中更详细地描述了gas是智能合约编程中非常重要的考虑因素。 Gas是限制以太坊允许交易消耗的最大计算量的资源。如果在计算过程中超出了gas限制，则会发生以下一系列事件：

* 抛出“out of gas”异常。
* 执行前的合约状态将被还原（恢复）。
* 用于支付gas的所有ether都被作为交易费用;没有退款

由于gas是由发起交易的用户支付的，因此不鼓励用户调用具有高gas成本的函数。因此，最大限度地降低合约函数的gas成本符合程序员的最大利益。为此，在构建智能合约时建议采用某些实践，以便最小化函数调用的gas成本。

==== 避免使用动态大小的数组

在一个动态大小的数组中，如果函数对每个元素执行操作或搜索某个特定元素，那么任何对数组的循环都会带来使用过多gas的风险。实际上，合约可能在找到所需结果之前或在对每个元素操作之前就耗尽了gas，从而浪费了时间和ether而没有产生任何结果。

==== 避免调用其他合约

调用其他合约，特别是当其函数的gas成本未知时，会引入gas耗尽的风险。避免使用未经过充分测试和广泛使用的库。库从其他程序员那里得到的审查越少，使用它的风险就越大。

==== 估算gas成本

如果你需要根据其参数估算执行某个合约方法所需的gas，你可以使用以下程序：

[source, javascript]
var contract = web3.eth.contract(abi).at(address);
var gasEstimate = contract.myAweSomeMethod.estimateGas(arg1, arg2, {from: account});

gasEstimate将告诉你执行所需的gas单元数量。这是一个估计，因为EVM的图灵完备性 - 创建一个需要大量不同gas量来能执行不同调用的函数相对简单。甚至产品代码也可能以微妙的方式改变执行路径，导致从一个调用到另一个调用的gas成本相差巨大。然而，大多数函数都是合理的，并且在大多数情况下，estimateGas会给出一个好的估计。

要从网络获得gas价格，你可以使用：

[source, javascript]
var gasPrice = web3.eth.getGasPrice();

从那里你可以估算出gas的成本：

[source, javascript]
var gasCostInEther = web3.fromWei((gasEstimate * gasPrice), 'ether');

让我们使用我们的gas估算函数来估算我们的Faucet示例的gas成本，使用 https://github.com/ethereumbook/ethereumbook/tree/develop/code/truffle/FaucetEvents[from the book's repository] 中的代码。

在开发模式下启动Truffle并执行<<estimateGas_function>>中的JavaScript文件。

[source, javascript]
[[estimateGas_function]]
.gas_estimates.js: Using the estimateGas function
====
[source,javascript]
----
var FaucetContract = artifacts.require("./Faucet.sol");

FaucetContract.web3.eth.getGasPrice(function(error, result) {
    var gasPrice = Number(result);
    console.log("Gas Price is " + gasPrice + " wei"); // "10000000000000"

    // Get the contract instance
    FaucetContract.deployed().then(function(FaucetContractInstance) {

		// Use the keyword 'estimateGas' after the function name to get the gas
		// estimation for this particular function (aprove)
		FaucetContractInstance.send(web3.toWei(1, "ether"));
        return FaucetContractInstance.withdraw.estimateGas(web3.toWei(0.1, "ether"));

    }).then(function(result) {
        var gas = Number(result);

        console.log("gas estimation = " + gas + " units");
        console.log("gas cost estimation = " + (gas * gasPrice) + " wei");
        console.log("gas cost estimation = " +
                    FaucetContract.web3.fromWei((gas * gasPrice), 'ether') + " ether");
    });
});
----
====

以下是Truffle开发控制台的情况：

++++
<pre data-type="programlisting">
$ <strong>truffle develop</strong>

truffle(develop)> <strong>exec gas_estimates.js</strong>
Using network 'develop'.

Gas Price is 20000000000 wei
gas estimation = 31397 units
gas cost estimation = 627940000000000 wei
gas cost estimation = 0.00062794 ether
</pre>
++++

建议你将函数的gas成本作为开发工作流的一部分进行评估，以避免在将合约部署到主网（mainnet）时出现任何意外。

=== 总结

在本章中，我们开始详细讨论智能合约，并介绍了Solidity合约编程语言。我们举了一个简单的示例合约，Faucet.sol，并逐渐完善了它，使它变得更加复杂，用它来探索Solidity语言的各个方面。在<<vyper_chap>>中，我们将使用另一种面向合约的编程语言Vyper。我们将比较Vyper和Solidity，展示这两种语言设计的一些差异，并加深我们对智能合约编程的理解。
