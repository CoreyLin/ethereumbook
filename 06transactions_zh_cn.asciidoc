[[tx_chapter]]
== 交易

交易是由外部拥有的账户发起的签名消息，由以太坊网络传输，并记录在以太坊区块链上。这个基本定义隐藏了许多令人惊讶和迷人的细节。查看交易的另一种方法是，它们是唯一可以触发状态更改或导致合约在EVM中执行的事物。以太坊是一个全局单例状态机，交易使状态机“滴答”，改变其状态。合约不会自己运行。以太坊不会自主运行。一切都始于交易。

在本章中，我们将剖析交易，展示它们的工作方式，并检查细节。请注意，本章的大部分内容针对的是那些有兴趣在低级别管理自己的交易的人，也许是因为他们正在编写钱包应用程序;如果你对使用现有的钱包应用程序感到满意，你不必担心这一点，尽管你可能会发现有趣的细节！

[[tx_struct]]
=== 交易的结构

首先让我们看一下交易的基本结构，因为它是在以太坊网络上序列化和传输的。接收序列化交易的每个客户端和应用程序将使用其自己的内部数据结构将其存储在内存中，可能使用在网络序列化交易中本身不存在的元数据进行修饰。网络序列化是交易的唯一标准形式。

交易是包含以下数据的序列化二进制消息：

Nonce:: 由始发EOA发出的序列号，用于防止重放消息

Gas price:: 发起人愿意支付的gas价格（以wei为单位）

Gas limit:: 发起人愿意为此次交易支付的最大gas量

Recipient:: 目的地以太坊地址

Value:: 要发送到目的地的ether数量

Data:: 可变长度二进制数据负载

v,r,s:: 始发EOA的ECDSA数字签名的三个组成部分

交易消息的结构使用递归长度前缀（RLP）编码方案进行序列化，该方案是专为以太坊中简单的字节完美数据序列化而创建的。以太坊中的所有数字都被编码为大端法整数，长度为8位的倍数。
	
请注意，为清楚起见，此处显示了字段标签（to，gas limit等），但它们不是交易序列化数据的一部分，交易序列化数据包含RLP编码的字段值。通常，RLP不包含任何字段分隔符或标签。 RLP的长度前缀用于标识每个字段的长度。超出定义长度的任何内容都属于结构中的下一个字段。

虽然这是实际的传输的交易结构，但大多数内部表示和用户界面可视化都通过从交易或区块链派生的附加信息来修饰。
	
例如，你可能会注意到用于标识发起者EOA的地址中没有“from”数据。这是因为EOA的公钥可以从ECDSA签名的v，r，s组件派生。反过来，地址可以从公钥派生。当你看到显示“from”字段的交易时，该字段由用于可视化交易的软件添加。客户端软件经常添加到交易中的其他元数据包括区块号（一旦它被挖矿并包括在区块链中）和交易ID（计算的哈希）。同样，此数据是从交易派生的，并不构成交易消息本身的一部分。

[[tx_nonce]]
=== 交易Nonce

nonce是交易中最重要和最难理解的部分之一。黄皮书中的定义（见<<references>>）如下：

____
+nonce+: 标量值，等于从此地址发送的交易数量，如果是具有相关代码的帐户，则为此帐户创建的合约创建数量。
____

严格来说，nonce是始发地址的属性;也就是说，它只在发送地址的上下文中有意义。但是，nonce不会明确作为帐户状态的一部分被存储在区块链上。相反，它是通过计算始发地址的已确认交易的数量来动态计算的。

有两种情况，交易计数nonce的存在很重要：包含在创建顺序中的交易的可用性特征，以及交易重复保护的重要特征。让我们看一下每个场景的示例：

1. 想象一下，你希望进行两笔交易。你有一笔6个ether的重要支付，还有一笔8个ether的支付。你首先签署并广播6-ether的交易，因为它是更重要的交易，然后你签署并广播第二笔8-ether的交易。遗憾的是，你忽略了这样一个事实：你的帐户只包含10个ether，因此网络无法接受这两笔交易：其中一笔将失败。因为你首先发送了更重要的6-ether，你可以理解地希望6-ether的交易通过而8-ether的交易被拒绝。但是，在像以太坊这样的去中心化系统中，节点可以按任意顺序接收交易;无法保证一笔交易在另一笔交易之前被传播到一个特定节点。因此，几乎可以肯定的是，某些节点首先接收6-ether交易，而其他节点首先接收8-ether交易。没有nonce的话，对于哪一个被接受而哪个被拒绝将是随机的。但是，如果包含nonce，则你发送的第一笔交易将具有nonce（比如3），而8-ether交易具有下一个nonce值（即4）。因此，该交易将被忽略，直到处理了从0到3的nonce的交易，即使它是先收到的。唷！


2. 现在想象你有一个100 ether的帐户。太棒了！你可以在网上找到一位接受ether付款的人，以获取你真正想购买的mcguffin-widget。你发送给他们2 ether，他们发送给你mcguffin-widget。这让人很愉快。为了进行2-ether付款，你签署了一笔交易，将你的帐户中的2个ether发送到他们的帐户，然后将其广播到以太坊网络进行验证并包含在区块链中。现在，在交易中没有nonce值的情况下，第二次将2 ether发送到同一地址的第二笔交易看起来与第一笔交易完全相同。这意味着，任何在以太坊网络上看到你的交易的人（这意味着每个人，包括收件人或你的敌人）都可以一次又一次地“重放”该交易，直到你的所有ether简单地通过复制和粘贴你的原始交易并将其重新发送到网络而消失。但是，如果交易数据中包含nonce值，则每笔交易都是唯一的，即使多次向同一个接收地址发送相同数量的ether也是如此。因此，通过将递增的nonce作为交易的一部分，任何人都无法“复制”你发起的支付。

总之，重要的是要注意，与比特币协议的“未花费交易输出”（UTXO）机制相比，使用nonce对于基于帐户的协议实际上是至关重要的。

[[tracking_nonce]]
==== 跟踪Nonces

实际上，nonce是源自一个帐户的已确认（即，链上）交易数量的最新计数。要找出nonce是什么，你可以查询区块链，例如通过web3接口。在运行MetaMask的浏览器中打开JavaScript控制台，或使用truffle console命令访问JavaScript web3库，然后键入：

++++
<pre data-type="programlisting">
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f")</strong>
40
</pre>
++++

[TIP]
====
nonce是一个从零开始的计数器，这意味着第一笔交易的nonce值为 0.在这个例子中，我们的交易计数为40，意味着0到39的nonce已经存在。下一笔交易的nonce是40。
====

你的钱包将跟踪其管理的每个地址的nonce。这样做相当简单，只要你只从一个点发起交易即可。假设你正在编写自己的钱包软件或其他一些发起交易的应用程序。你如何跟踪nonces？

创建一笔新交易时，将在序列中分配下一个nonce。但在确认之前，它不会计入getTransactionCount总计。

[[get_tx_count_bug]]
[WARNING]
====
使用getTransactionCount函数计算待处理的交易时要小心，因为如果连续发送一些交易，可能会遇到一些问题。
====

让我们来看一个例子：

++++
<pre data-type="programlisting">
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")</strong>
40
&gt; <strong>web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.toWei(0.01, "ether")});</strong>
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")</strong>
41
&gt; <strong>web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.toWei(0.01, "ether")});</strong>
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")</strong>
41
&gt; <strong>web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.toWei(0.01, "ether")});</strong>
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")</strong>
41
</pre>
++++

如你所见，我们发送的第一笔交易将交易计数增加到41，显示待处理的交易。但是当我们快速连续发送三个以上的交易时，getTransactionCount调用没有对它们进行计数。它只计算一个，即使你可能期望在mempool中有三个待处理。如果我们等待几秒钟以允许网络通信稳定下来，则getTransactionCount调用将返回预期的数字。但在此期间，虽然有多笔待处理的交易，但它可能对我们没有帮助。

编写构建交易的应用程序时，它不能依赖getTransactionCount来处理待处理的交易。只有当待处理和已确认的计数相等（所有交易都已确认）时，你才能信任getTransactionCount的输出从而启动你的nonce计数器。此后，跟踪应用程序中的nonce，直到每笔交易被确认。

Parity的JSON RPC接口提供了parity_nextNonce函数，该函数返回应在交易中使用的下一个nonce。 parity_nextNonce函数正确计算nonce，即使你快速连续构造了几笔交易而没有确认它们：

++++
<pre data-type="programlisting">
$ <strong>curl --data '{"method":"parity_nextNonce", \
  "params":["0x9e713963a92c02317a681b9bb3065a8249de124f"],\
  "id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST \
  localhost:8545</strong>

{"jsonrpc":"2.0","result":"0x32","id":1}
</pre>
++++

[[parity_curl]]
[TIP]
====
Parity有一个用于访问JSON RPC接口的Web控制台，但在这里我们使用命令行HTTP客户端来访问它。
====

[[gaps_nonce]]
==== Nonces中的缺口，重复Nonces，以及确认

如果以编程方式创建交易，则跟踪nonce非常重要，尤其是如果你同时从多个独立进程执行此操作。

以太坊网络基于nonce顺序处理交易。这意味着如果你使用nonce 0传输一笔交易，然后使用nonce 2传输一笔交易，则第二笔交易将不被包含在任何区块中。它将存储在mempool中，而以太坊网络则等待丢失的nonce出现。所有节点都将假设缺少的nonce只是被推迟了，并且具有nonce 2的交易被不按顺序接收。

如果你随后使用缺失的nonce 1传输一笔交易，则将处理和包含两笔交易（nonce 1和2）（当然，如果有效）。一旦填补了缺口，网络就可以对它在mempool中保存的无序交易进行挖矿。

这意味着如果你按顺序创建多笔交易并且其中一笔交易未正式包含在任何区块中，则所有后续交易将“卡住”，等待丢失的nonce。一笔交易可以在nonce序列中产生无意的“缺口”，因为它无效或者gas不足。为了让一切重新开始，你必须使用缺失的nonce传输有效的交易。你应该同样注意，一旦网络验证了具有“缺失”的nonce的交易，所有具有后续nonce的广播交易将逐渐变为有效;无法“召回/撤销”交易！

另一方面，如果你意外复制了一个nonce，例如通过发送具有相同nonce但接收者或价值不同的两笔交易，则其中一笔将被确认，一笔将被拒绝。哪一笔交易将被确认将由它们到达接收它们的第一个验证节点的顺序确定 - 即，它将是相当随机的。

如你所见，跟踪nonce是必要的，如果你的应用程序无法正确管理该过程，你将遇到问题。不幸的是，如果你尝试同时执行此操作会变得更加困难，我们将在下一节中看到。

[[concurrency]]
==== 并发，交易发起和Nonces

并发是计算机科学的一个复杂方面，有时会出乎意料地出现，尤其是在像以太坊这样的去中心化和分布式实时系统中。

简单来说，并发是指你可以通过多个独立系统同时进行计算。这些可以在相同的程序（例如，多线程）中，在相同的CPU（例如，多重处理）上，或在不同的计算机（即，分布式系统）上。根据定义，以太坊是一个允许操作（节点，客户端，DApps）并发但通过共识机制强制执行单例状态的系统。

现在，假设你有多个独立的钱包应用程序，它们从相同的地址生成交易。这种情况的一个例子是交易所处理从交易所的热钱包（热钱包的密钥在线存储，与冷钱包的密钥从不在线存储相反）的提款。理想情况下，你希望有多台计算机处理提款，因此它不会成为瓶颈或单点故障。然而，这很快就会成为问题，因为有多台计算机产生提款将导致一些棘手的并发问题，其中最重要的是选择nonce。多台计算机如何从同一个热钱包帐户协调生成，签名和广播交易？

你可以使用一台计算机以先到先得的方式将nonce分配给所有计算机来签署交易。但是，这台计算机现在是单点故障。更糟糕的是，如果分配了几个nonce并且其中一个永远不会被使用（由于计算机处理具有该nonce的交易的失败），所有后续交易都会被卡住。

另一种方法是生成交易，但不为它们分配nonce（因此让它们未签名 - 记住nonce是交易数据的组成部分，因此需要包含在验证交易的数字签名中） 。然后，你可以将这些交易排队到一个签署它们的节点，并跟踪nonces。但是，这又是一个过程中的阻塞点：交易签名和nonces的跟踪是你的操作的一部分，可能会在高负载下变得拥挤，而未签名交易的生成是你不需要真正并行化的部分。你会有一些并发，但这个过程的关键部分却缺乏并发。

最后，除了跟踪独立进程中的帐户余额和交易确认的难度之外，这些并发问题迫使大多数实现避免并发，并且创建瓶颈，例如处理交易所中的所有提款交易的单个进程，或设置多个热钱包可以完全独立地进行提款，只需要间歇性地重新平衡。

[[tx_gas]]
=== 交易Gas

我们在前面的章节中谈到了gas，我们在<<gas>>中更详细地讨论了它。但是，让我们介绍一下有关交易的gasPrice和gasLimit组件的作用的一些基础知识。

gas是以太坊的燃料。gas不是ether - 它是一种独立的虚拟货币，拥有其自身与ether的汇率。以太坊使用gas来控制交易可以使用的资源量，因为它将在全球数千台计算机上处理。开放式（图灵完备）计算模型需要某种形式的计量，以避免拒绝服务攻击或无意中吞噬资源的交易。

gas与ether分开，以保护系统免受随着ether价值的快速变化而可能出现的波动，并且还作为管理gas支付的各种资源成本之间的重要和敏感比率的方法。 （即计算，内存和存储）。

交易中的gasPrice字段允许交易发起人设定他们愿意支付以换取gas的价格。价格以wei每gas单位计量。例如，在<<intro_chapter>>的示例交易中，你的钱包将gasPrice设置为3 gwei（3 gigawei 或 3 billion wei）。

[TIP]
====
受欢迎的 https://ethgasstation.info/[ETH Gas Station] 提供有关以太坊主网络的当前gas价格和其他相关gas指标的信息。
====

钱包可以在发起的交易中调整gasPrice，以实现更快的交易确认。 gasPrice越高，交易可能越快被确认。相反，优先级较低的交易可以降低价格，导致更慢的确认速度。 gasPrice可以设置的最小值为零，这意味着免费交易。在区块空间需求低的时期，这种交易很可能会被挖矿。

[NOTE]
====
最低可接受的gasPrice为零。这意味着钱包可以生成完全免费的交易。根据容量，这些可能永远不会得到确认，但协议中没有任何内容禁止免费交易。你可以在以太坊区块链中找到成功包含此类交易的几个示例。
====

[[gas_price_suggestion]]
web3接口提供了gasPrice建议，通过计算几个区块的中位数价格（我们可以使用truffle控制台或任何JavaScript web3控制台来执行此操作）：

++++
<pre data-type="programlisting">
> <strong>web3.eth.getGasPrice(console.log)</strong>
> null BigNumber { s: 1, e: 10, c: [ 10000000000 ] }
</pre>
++++

[[calc_gas_price]]
与gas有关的第二个重要字段是gasLimit。简单来说，gasLimit给出交易发起人愿意购买的最大gas单位数量，以完成交易。对于简单支付，意味着将ether从一个EOA转移到另一个EOA的交易，所需的gas量固定为21,000个gas单位。要计算需要花费多少ether，你需要用你愿意支付的gasPrice乘以21,000。例如：

++++
<pre data-type="programlisting">
> <strong>web3.eth.getGasPrice(function(err, res) {console.log(res*21000)} )</strong>
> 210000000000000
</pre>
++++

如果你的交易的目的地地址是合约，那么可以估算所需的gas量，但无法准确确定。这是因为合约可以评估导致不同执行路径的不同条件，总的gas成本不同。合约可能只执行简单的计算或更复杂的计算，具体取决于你无法控制且无法预测的条件。为了演示这一点，让我们看一个例子：我们可以编写一个智能合约，每次调用它时都会递增一个计数器，并执行一个特定的循环，其循环次数等于调用次数。也许在第100次调用中，它会像彩票一样给出特殊奖励，但需要进行额外的计算以计算奖金。如果你将合约调用99次只有一件事会发生，但是在第100次调用时会发生一些非常不同的事情。你需要支付的gas数量取决于在你的交易包含在一个区块之前有多少其他交易已经调用该函数。也许你的估计是基于第99次交易，但就在你的交易被确认之前，其他人调用了这个合约，并且是第99次调用。现在你是第100个要调用该函数的交易，计算量（和gas成本）要高得多。

借用以太坊中使用的常见类比，你可以将gasLimit视为汽车油箱的容量（你的汽车就是交易）。你可以用你认为旅途所需的燃油（为验证交易所需的计算）填充油箱。你可以在一定程度上估算燃油量，但你的旅程可能会出现意外变化，例如改道（更复杂的执行路径），这会增加燃油消耗。

然而，与油箱作类比有些误导。它实际上更像是一家加油站公司的信用账户，根据你实际使用的燃油量，你可以在旅行结束后付款。当你传输交易时，最初的验证步骤之一是检查发起的帐户是否有足够的ether支付gasPrice *燃气费。但是，在交易完成执行之前，实际上并未从你的帐户中扣除金额。你只需支付交易实际消耗的燃油费用，但在发送交易之前，你必须有足够的余额支付你愿意支付的最高金额。

[[tx_recipient]]
=== 交易接收者

交易的接收者在to字段中指定。这包含一个20字节的以太坊地址。地址可以是EOA或合约地址。

以太坊没有进一步验证该字段。任何20字节的值都被认为是有效的。如果20字节的值对应于没有相应私钥或合约的地址，则该交易仍然有效。以太坊无法知道地址是否正确地派生自现有的公钥（因此来源于私钥）。

[WARNING]
====
以太坊协议不验证交易中的接收者地址。你可以发送到没有相应私钥或合约的地址，从而“烧掉”ether，使其永远不被花费。验证应在用户接口级别完成。
====

将交易发送到错误的地址可能会烧掉发送的ether，使其永远无法访问（不可花费），因为大多数地址没有已知的私钥，因此无法生成签名来使用它。假设地址验证发生在用户接口级别（参见<<EIP55>>）。实际上，烧掉ether有许多正当理由 - 例如，作为对支付渠道和其他智能合约作弊的抑制因素 - 并且由于ether的数量是有限的，烧掉ether有效地将烧掉的价值分配给所有ether持有者（与他们持有的ether量成比例）。

[[tx_value_data]]
=== 交易价值（value）和数据（data）

交易的主要“有效负载”包含在两个字段中：价值（value）和数据（data）。交易可以同时具有价值和数据，仅具有价值，仅具有数据，或者既不具有价值也不具有数据。所有四种组合都有效。

仅具有价值的交易是支付。仅包含数据的交易是调用。具有价值和数据的交易既是支付，也是调用。既没有价值也没有数据的交易 - 这可能只是浪费gas！但它仍然有可能。

让我们尝试所有这些组合。首先，我们将设置钱包中的源地址和目标地址，只是为了让演示更容易阅读：

[source,javascript]
----
src = web3.eth.accounts[0];
dst = web3.eth.accounts[1];
----

我们的第一笔交易只包含一个价值（支付），没有数据负载：

[[tx_value_nodata_src]]
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, \
  value: web3.toWei(0.01, "ether"), data: ""});
----

我们的钱包显示一个确认屏幕，指示要发送的价值，如<<parity_txdemo_value_nodata>>中所示。

[[parity_txdemo_value_nodata]]
.Parity wallet showing a transaction with value, but no data
image::images/parity_txdemo_value_nodata.png["Parity wallet showing a transaction with value, but no data"]


下一个示例同时指定价值和数据有效负载：

[[tx_value_data_src]]
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, \
  value: web3.toWei(0.01, "ether"), data: "0x1234"});
----

我们的钱包显示一个确认屏幕，指示要发送的价值以及数据有效负载，如<<parity_txdemo_value_data>>中所示。

[[parity_txdemo_value_data]]
.Parity wallet showing a transaction with value and data
image::images/parity_txdemo_value_data.png["Parity wallet showing a transaction with value and data"]

下一笔交易包括数据有效负载，但指定价值为零：

[[tx_novalue_data_src]]
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, value: 0, data: "0x1234"});
----

我们的钱包显示一个确认屏幕，显示零价值和数据有效负载，如<<parity_txdemo_novalue_data>>中所示。

[[parity_txdemo_novalue_data]]
.Parity wallet showing a transaction with no value, only data
image::images/parity_txdemo_novalue_data.png["Parity wallet showing a transaction with no value, only data"]

最后，最后一笔交易既不包含要发送的价值也不包含数据有效负载：

[[tx_novalue_nodata_src]]
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, value: 0, data: ""}));
----

我们的钱包显示一个指示零价值的确认屏幕，如<<parity_txdemo_novalue_nodata>>中所示。

[[parity_txdemo_novalue_nodata]]
.Parity wallet showing a transaction with no value, and no data
image::images/parity_txdemo_novalue_nodata.png["Parity wallet showing a transaction with no value, and no data"]

[[value_EOA_contracts]]
==== 向EOA和合约传输价值（value）

当你构建包含价值的以太坊交易时，它相当于支付。此类交易的行为会有所不同，具体取决于目的地地址是否为合约。

对于EOA地址，或者更确切地说，对于没有在区块链上标记为合约的任何地址，以太坊将记录状态更改，将你发送的价值添加到地址的余额中。如果该地址以前没人见过，则会将其添加到客户端的状态的内部表示中，并将其余额初始化为你的支付金额。

如果目标地址（to）是合约，则EVM将执行合约并尝试调用交易的数据有效负载中指定的函数。如果你的交易中没有数据，EVM将调用fallback函数，如果该函数是payable的，将执行它以确定下一步操作。如果没有fallback函数，那么交易的效果将是增加合约的余额，就像对钱包的支付一样。

合约可以通过在调用函数时立即抛出异常或由函数中编码的条件确定来拒绝传入的支付。如果函数成功终止（没有异常），则更新合约的状态以反映合约的ether余额的增加。

[[data_EOA]]
==== 将数据有效负载传输到EOA或合约

当你的交易包含数据时，很可能会将其发送到合约地址。这并不意味着你无法将数据有效负载发送到EOA，这在以太坊协议中完全有效。但是，在这种情况下，数据的解释取决于你用于访问EOA的钱包。它被以太坊协议忽略。大多数钱包也会忽略交易中传入到EOA的任何数据。将来，有可能出现允许钱包按照合约的方式解释数据的标准，从而允许交易调用在用户钱包内运行的函数。关键的区别在于，与合约执行不同，EOA对数据有效负载的任何解释都不受以太坊的共识规则的约束。

现在，让我们假设你的交易正在将数据传输到合约地址。在这种情况下，EVM将数据解释为合约调用。大多数合约更具体地将此数据用作函数调用，调用命名函数并将任何编码参数传递给函数。

发送到ABI兼容合约（你可以假设所有合约都是）的数据有效负载是十六进制序列化编码：

函数选择器:: 函数原型的Keccak-256哈希的前4个字节。这允许合约明确地标识你要调用的函数。

函数参数:: 函数的参数，根据ABI规范中定义的各种基本类型的规则进行编码。

在<<solidity_faucet_example>>中，我们为取款定义了一个函数：

[[withdraw_function_src]]
[source,solidity]
----
function withdraw(uint withdraw_amount) public {
----

函数的原型定义为包含函数名称的字符串，后跟每个参数的数据类型，括在括号中并用逗号分隔。这里的函数名是withdraw，它接受一个uint（这是uint256的别名）的参数，所以withdraw的原型是：

[source,solidity]
----
withdraw(uint256)
----

让我们计算一下这个字符串的Keccak-256哈希值：

++++
<pre data-type="programlisting">
> <strong>web3.sha3("withdraw(uint256)");</strong>
'0x2e1a7d4d13322e7b96f9a57413e1525c250fb7a9021cf91d1540d5b69f16a49f'
</pre>
++++

哈希的前4个字节是0x2e1a7d4d。这是我们的“函数选择器”的值，它将告诉合约我们想要调用哪个函数。

接下来，让我们计算一个值作为参数withdraw_amount传递。我们想要提取0.01 ether。让我们将其编码为十六进制序列的大端无符号256位整数，以wei计价：

++++
<pre data-type="programlisting">
> <strong>withdraw_amount = web3.toWei(0.01, "ether");</strong>
'10000000000000000'
> <strong>withdraw_amount_hex = web3.toHex(withdraw_amount);</strong>
'0x2386f26fc10000'
</pre>
++++

现在，我们将函数选择器添加到取款金额中（填充到32个字节）：

----
2e1a7d4d000000000000000000000000000000000000000000000000002386f26fc10000
----

这是我们交易的数据有效负载，调用withdraw函数并请求0.01 ether作为withdraw_amount。

[[contract_reg]]
=== 特殊交易：合约创建

我们应该提到的一个特殊情况是一种交易，其在区块链上创建新合约并将其部署以供将来使用。合约创建交易被发送到称为零地址（zero address）的特殊目标地址;合同注册交易中的to字段包含地址0x0。该地址既不代表EOA（没有相应的私钥 - 公钥对）也不代表合约。它永远不会花费ether或发起交易。它仅用作目的地，具有“创建此合约”的特殊含义。

虽然零地址仅用于创建合约，但有时会从各种地址接收支付付款。对此有两种解释：要么是偶然的，导致失去ether，要么是故意的ether燃烧（故意通过将其发送到一个永远不会花费的地址来破坏ether）。但是，如果你想进行有意的ether燃烧，你应该让网络明确你的意图并使用专门指定的燃烧地址：

[[burn_address]]
----
0x000000000000000000000000000000000000dEaD
----

[WARNING]
====
发送到指定燃烧地址的任何ether将变得不可花费并永远丢失。
====

合约创建交易只需要包含一个数据有效负载，其中包含将创建合约的已编译字节码。此交易的唯一效果是创建合约。如果要为新合约设置起始余额，则可以在value（价值）字段中包含ether数量，但这完全是可选的。如果你在没有数据有效负载（无合约）的情况下向合约创建地址发送价值（ether），则效果与发送到燃烧地址相同 - 没有合约被创建，因此ether丢失。

例如，我们可以通过在数据有效负载中包含合约手动地创建到零地址的交易来创建<<intro_chapter>>中使用的Faucet.sol合约。合约需要编译成字节码表示。这可以使用Solidity编译器完成：

++++
<pre data-type="programlisting">
$ <strong>solc --bin Faucet.sol</strong>

Binary:
6060604052341561000f57600080fd5b60e58061001d6000396000f30060606040526004361060...
</pre>
++++

也可以从Remix在线编译器获得相同的信息。

现在我们可以创建交易：

++++
<pre data-type="programlisting">
> <strong>src = web3.eth.accounts[0];</strong>
> <strong>faucet_code = \
  "0x6060604052341561000f57600080fd5b60e58061001d6000396000f300606060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632e1a7d4d146041575b005b3415604b57600080fd5b605f60048080359060200190919050506061565b005b67016345785d8a00008111151515607757600080fd5b3373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f19350505050151560b657600080fd5b505600a165627a7a72305820d276ddd56041f7dc2d2eab69f01dd0a0146446562e25236cf4ba5095d2ee802f0029";</strong>
> <strong>web3.eth.sendTransaction({from: src, to: 0, data: faucet_code, \
  gas: 113558, gasPrice: 200000000000});</strong>

"0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b"
</pre>
++++

最好总是指定一个to参数，即使在零地址合约创建的情况下，因为意外地将ether发送到0x0并永远丢失它的成本太高了。你还应该指定gasPrice和gasLimit。

合约一旦被挖矿，我们就可以在Etherscan区块浏览器上看到它，如<<publish_contract_from_web3>>所示。

[[publish_contract_from_web3]]
.Etherscan showing the contract successfully mined
image::images/contract_published.png["Etherscan showing the contract successfully mined"]

我们可以查看交易收据（receipt）以获取有关合约的信息：

++++
<pre data-type="programlisting">
> <strong>eth.getTransactionReceipt( \
  "0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b");</strong>

{
  blockHash: "0x6fa7d8bf982490de6246875deb2c21e5f3665b4422089c060138fc3907a95bb2",
  blockNumber: 3105256,
  contractAddress: "0xb226270965b43373e98ffc6e2c7693c17e2cf40b",
  cumulativeGasUsed: 113558,
  from: "0x2a966a87db5913c1b22a59b0d8a11cc51c167a89",
  gasUsed: 113558,
  logs: [],
  logsBloom: \
    "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  status: "0x1",
  to: null,
  transactionHash: \
    "0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b",
  transactionIndex: 0
}
</pre>
++++

这包括合约地址，我们可以使用该地址向合约发送资金或数据，如上一节所示：

++++
<pre data-type="programlisting">
> <strong>contract_address = "0xb226270965b43373e98ffc6e2c7693c17e2cf40b"</strong>
> <strong>web3.eth.sendTransaction({from: src, to: contract_address, \
  value: web3.toWei(0.1, "ether"), data: ""});</strong>

"0x6ebf2e1fe95cc9c1fe2e1a0dc45678ccd127d374fdf145c5c8e6cd4ea2e6ca9f"

> <strong>web3.eth.sendTransaction({from: src, to: contract_address, value: 0, \
  data: "0x2e1a7d4d000000000000000000000000000000000000000000000000002386f26fc10000"});</strong>

"0x59836029e7ce43e92daf84313816ca31420a76a9a571b69e31ec4bf4b37cd16e"
</pre>
++++

过了一会儿，两笔交易都在Etherscan上可见，如<<publish_contract_transactions>>所示。

[[publish_contract_transactions]]
.Etherscan showing the transactions for sending and receiving funds
image::images/published_contract_transactions.png["Etherscan showing the transactions for sending and receiving funds"]


[[digital_sign]]
=== 数字签名

到目前为止，我们还没有深入研究有关数字签名的任何细节。在本节中，我们将了解数字签名的工作原理以及如何在不泄露私钥的情况下使用它们来呈现私钥的所有权证明。

[[ecdsa]]
==== 椭圆曲线数字签名算法

以太坊中使用的数字签名算法是椭圆曲线数字签名算法（Elliptic Curve Digital Signature Algorithm，ECDSA）。它基于椭圆曲线私有 - 公共密钥对，如<<elliptic_curve>>中所述。

数字签名在以太坊中有三个用途（参见下面的侧栏）。首先，签名证明私钥的所有者（其暗示是以太坊账户的所有者）已授权ether的支出或合约的执行。其次，它保证不可否认性：授权证明是不可否认的。第三，签名证明交易数据在交易被签名后未被任何人修改过。

[[digital_signature_definition]]
.维基百科对数字签名的定义
****
数字签名是用于呈现数字消息或文档的真实性的数学方案。有效的数字签名使接收者有理由相信该消息是由已知发送者（身份验证）创建的，发送者不能否认发送过消息（不可否认），并且消息在传输过程中未被更改（完整性）。

_Source: https://en.wikipedia.org/wiki/Digital_signature_
****

[[digital_sign_work]]
==== 数字签名的工作原理

数字签名是一种由两部分组成的数学方案。第一部分是使用私钥（签名密钥）从消息（在我们的例子中是交易）中创建签名的算法。第二部分是一种算法，允许任何人仅使用消息和公钥来验证签名。

[[digital_sign_create]]
===== 创建数字签名

在以太坊的ECDSA实现中，被签名的“消息”是交易，或者更确切地说，是来自交易的RLP编码数据的Keccak-256哈希。签名密钥是EOA的私钥。结果是签名：

[latexmath]
++++
\begin{equation}
{Sig} = F_{sig}(F_{keccak256}(m), k)
\end{equation}
++++

其中：

* _k_ 是签名私钥。
* _m_ 是RLP编码的交易。
* _F_~_keccak256_~ 是Keccak-256哈希函数。
* _F_~_sig_~ 是签名算法。
* _Sig_ 是由此产生的签名。

[[sign_function]]
函数 _F_~_sig_~ 产生一个由两个值组成的签名Sig，通常称为r和s：

[latexmath]
++++
\begin{equation}
{Sig} = (r, s)
\end{equation}
++++

[[verify_sign]]
==== 验证签名

要验证签名，必须具有签名（r和s），序列化交易以及与用于创建签名的私钥对应的公钥。从本质上讲，验证签名意味着“只有生成此公钥的私钥的所有者才能在此交易中生成此签名”。

签名验证算法获取消息（即，我们使用的交易的哈希），签名者的公钥和签名（r和s值），并且如果签名对该消息和公钥有效则返回true。

[[ecdsa_math]]
==== ECDSA数学

如前所述，签名由数学函数 _F_~_sig_~ 创建，该函数生成由两个值r和s组成的签名。在本节中，我们将更详细地介绍函数 _F_~_sig_~ 。

签名算法首先以加密安全的方式生成转瞬即逝的（临时）私钥。此临时密钥用于计算r和s值，以确保攻击者无法在以太坊网络上观看已签名的交易来计算发送者的实际私钥。

正如我们从<<pubkey>>所知，短暂的私钥用于派生相应的（短暂的）公钥，因此我们有：

* 加密安全随机数q，作为短暂私钥
* 相应的短暂公钥Q，由q和椭圆曲线生成点G生成

然后，数字签名的r值是短暂公钥Q的x坐标。

从那里，算法计算签名的s值，这样：

++++
<ul class="simplelist">
<li><em>s</em> &#8801; <em>q</em><sup>-1</sup> (<em>Keccak256</em>(<em>m</em>) + <em>r</em> * <em>k</em>)  &nbsp;  &nbsp; (<em>mod p</em>)</li>
</ul>
++++

其中：

* _q_ 是短暂的私钥。
* _r_ 是短暂公钥的x坐标。
* _k_ 是签名（EOA所有者）私钥。
* _m_ 是交易数据。
* _p_ 是椭圆曲线的素数阶。

验证是签名生成函数的反转，使用r和s值以及发送者的公钥来计算值Q，该值是椭圆曲线上的一个点（签名创建中使用的短暂公钥）。步骤如下：

1. 检查所有输入的结构是否正确
2. 计算 _w_ = __s__^-1^ _mod p_
3. 计算 _u~1~_ = __Keccak256__(__m__) * _w_ _mod p_
4. 计算 _u~2~_ = _r_ * _w_ _mod p_
5. 最后，计算椭圆曲线上的点 _Q_ &#8801; _u~1~ * _G_ + _u~2~_ * _K_  {nbsp} {nbsp} (_mod p_)

其中：

* _r_ 和 _s_ 是签名值
* _K_ 是签名者（EOA所有者的）公钥
* _m_ 是已签名的交易数据
* _G_ 是椭圆曲线生成点
* _p_ 是椭圆曲线的素数阶

如果计算的点Q的x坐标等于r，则验证者可以断定签名是有效的。

请注意，在验证签名时，私钥既不知道也不被透露。

[TIP]
====
ECDSA必然是一个相当复杂的数学问题;完整的解释超出了本书的范围。许多优秀的在线指南将一步一步带你浏览：搜索“ECDSA explained”或尝试以下内容： http://bit.ly/2r0HhGB[] 。
====

[[tx_sign]]
==== 交易签名实践

为了产生有效的交易，发起者必须使用椭圆曲线数字签名算法对消息进行数字签名。当我们说“签署交易”时，我们实际上是指“签署RLP序列化交易数据的Keccak-256哈希”。签名应用于交易数据的哈希，而不是交易本身。
	
要在以太坊签署交易，发起人必须：

1. 创建一个交易数据结构，包含九个字段： +nonce+, +gasPrice+, +gasLimit+, +to+, +value+, +data+, +chainID+, +0+, +0+.
2. 生成交易数据结构的RLP编码的序列化消息。
3. 计算此序列化消息的Keccak-256哈希值。
4. 计算ECDSA签名，使用原始EOA的私钥对哈希进行签名。
5. 将ECDSA签名的计算v，r和s值附加（追加）到交易。

特殊签名变量v表示两件事：链ID和恢复标识符，以帮助ECDSArecover函数检查签名。它计算为27或28中的一个，或链ID加倍加35或36.有关链ID的更多信息，请参阅<<raw_tx_eip155>>。恢复标识符（“旧式”签名中的27或28，或完整的Spurious Dragon风格交易中的35或36）用于表示公钥的y部分的奇偶性（请参阅<<sign_prefix>>更多细节）。

[NOTE]
====
在区块＃2,675,000，以太坊实施了“Spurious Dragon”硬分叉，除了其他变化外，还引入了一种新的签名方案，其中包括交易重放保护（防止一个网络的交易在其他网络上被重放）。这种新的签名方案在EIP-155中规定。此更改会影响交易及其签名的形式，因此必须注意三个签名变量中的第一个（即v），它采用两种形式中的一种，并表示被包含在被哈希的交易消息中的字段。
====


[[raw_tx]]
==== 原始交易的创建和签名

在本节中，我们将使用ethereumjs-tx库创建一笔原始交易并对其进行签名。这演示了通常在钱包中使用的功能，或代表用户签署交易的应用程序。此示例的源代码位于本书的 https://github.com/ethereumbook/ethereumbook/blob/develop/code/web3js/raw_tx/raw_tx_demo.js[GitHub repository] 中的raw_tx_demo.js文件中：

[[raw_tx_demo_source]]
[source,javascript]
----
include::code/web3js/raw_tx/raw_tx_demo.js[]
----

[[raw_tx_demo_run]]
运行示例代码会产生以下结果：

++++
<pre data-type="programlisting">
$ <strong>node raw_tx_demo.js</strong>
RLP-Encoded Tx: 0xe6808609184e72a0008303000094b0920c523d582040f2bcb1bd7fb1c7c1...
Tx Hash: 0xaa7f03f9f4e52fcf69f836a6d2bbc7706580adce0a068ff6525ba337218e6992
Signed Raw Transaction: 0xf866808609184e72a0008303000094b0920c523d582040f2bcb1...
</pre>
++++

[[raw_tx_eip155]]
==== 使用EIP-155创建原始交易

EIP-155“简单重放攻击保护”标准规定了重放攻击保护的交易编码，其在签名之前包括交易数据内的链标识符。这确保了为一个区块链（例如，以太坊主网络）创建的交易在另一个区块链（例如，以太坊经典Ethereum Classic或Ropsten测试网络）上是无效的。因此，在一个网络上广播的交易不能在另一个网络上重播（重放）。

EIP-155在交易数据结构的主要六个字段中添加三个字段，即链标识符，0，0.这三个字段在被编码和哈希之前添加到交易数据中。因此，它们更改交易的哈希值，稍后将应用到签名。通过在被签名的数据中包含链标识符，交易签名可以防止任何更改，因为如果链标识符被修改，则签名无效。因此，EIP-155使得交易不可能在另一条链上重放，因为签名的有效性取决于链标识符。

链标识符字段根据交易所针对的网络获取值，如<<chain_id_table>>所述

[[chain_id_table]]
.Chain identifiers
[options="header"]
|======
| Chain | Chain ID
| Ethereum mainnet | 1
| Morden (obsolete), Expanse | 2
| Ropsten | 3
| Rinkeby | 4
| Rootstock mainnet | 30
| Rootstock testnet | 31
| Kovan | 42
| Ethereum Classic mainnet | 61
| Ethereum Classic testnet | 62
| Geth private testnets | 1337
|======

生成的交易结构经过RLP编码，哈希和签名。略微修改签名算法以对v前缀中的链标识符进行编码。

有关更多详细信息，请参阅 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md[the EIP-155 specification].

[[sign_prefix]]
=== 签名前缀值(v)和公钥恢复

如<<tx_struct>>中所述，交易消息不包含“from”字段。这是因为发起人的公钥可以直接从ECDSA签名中计算出来。获得公钥后，你可以轻松计算出地址。恢复签名者公钥的过程称为公钥恢复。

给定在 <<ecdsa_math>> 中计算的值r和s，我们可以计算两个可能的公钥。

首先，我们从签名中的x坐标r值计算两个椭圆曲线点R和R'。有两个点是因为椭圆曲线在x轴上是对称的，因此对于任何值x，都有两个可能的值适合曲线，每一个在x轴的每一侧。

从r我们还计算r-1【校正】，它是r的乘法逆矩阵。

最后，我们计算z，它是消息哈希的n个最低位，其中n是椭圆曲线的阶数。

这两个可能的公钥是:

++++
<ul class="simplelist">
<li><em>K</em><sub>1</sub> = <em>r</em><sup>&#x2013;1</sup> (<em>sR</em> &#x2013; <em>zG</em>)</li>
</ul>
++++

以及

++++
<ul class="simplelist">
<li><em>K</em><sub>2</sub> = <em>r</em><sup>&#x2013;1</sup> (<em>sR</em><sup>'</sup> &#x2013; <em>zG</em>)</li>
</ul>
++++

其中：

* __K__~1~ and __K__~2~ 是签名者公钥的两个可能值。
* __r__^-1^ 是签名r值的乘法逆矩阵。
* _s_ 是签名的值。
* __R__ 和 __R__^'^ 是短暂公钥Q的两种可能性。
* _z_ 是消息哈希的n个最低位。
* _G_ 是椭圆曲线生成点。

为了提高效率，交易签名包括前缀值v，它告诉我们两个可能的R值中的哪一个是短暂的公钥。如果v是偶数，则R是正确的值。如果v是奇数，则R'是正确的值。这样，我们只需要计算R的一个值以及K仅有的一个值。

[[offline_sign]]
=== 分离签名和传输(离线签名)

交易被签名后，即可传输到以太坊网络。创建，签名和广播交易的三个步骤通常作为单个操作发生，例如使用web3.eth.sendTransaction。但是，正如你在<<raw_tx>>中看到的那样，你可以通过两个单独的步骤创建和签署交易。获得签名交易后，你可以使用web3.eth.sendSignedTransaction传输它，该函数以十六进制编码并签名的交易作为参数，并在以太坊网络上传输交易。

你为什么要分开交易的签名和传输？最常见的原因是安全性。签署交易的计算机必须具有加载在内存中的未锁定私钥。进行传输的计算机必须连接到互联网（并运行以太坊客户端）。如果这两个功能在一台计算机上，那么你在在线系统上有私钥，这非常危险。分离签名和传输的功能，并在不同的机器上（分别在离线和在线设备上）执行它们，这被称为离线签名，并且是常见的安全实践。

<<offline_signing>> 显示了以下过程：

1. 在在线计算机上创建一个未签名的交易，其中可以检索帐户的当前状态，特别是当前的nonce和可用资金。
2. 将未签名的交易转移到用于交易签名的“气隙的（air-gapped）”离线设备，例如，通过二维码或USB闪存盘。
3. 将签名的交易发送回在线设备，以便在以太坊区块链上进行广播，例如，通过二维码或USB闪存盘。

[[offline_signing]]
.Offline signing of Ethereum transactions
image::images/offline_signing.png["Offline signing of Ethereum transactions"]

根据你所需的安全级别，你的“离线签名”计算机可能与在线计算机有不同程度的分离，从孤立和防火墙子网（在线但隔离）到称为气隙系统的完全脱机系统。在气隙系统中根本没有网络连接 - 计算机与在线环境之间存在“空中”差距。要对交易进行签名，你可以使用数据存储介质或（更好）网络摄像头和二维码将其传输到气隙计算机或从气隙计算机传输出来。当然，这意味着你必须手动传输要签名的每笔交易，并且这不能扩展。

虽然没有多少环境可以使用完全气隙系统，但即使是很小程度的隔离也具有显著的安全性优势。例如，具有仅允许消息队列协议通过的防火墙的隔离子网可以提供大大减少的攻击面，并且比在线系统上签名具有更高的安全性。许多公司为此目的使用ZeroMQ（0MQ）等协议。通过这样的设置，交易被序列化并排队等待签名。队列协议以类似于TCP套接字的方式将序列化消息发送到签名计算机。签名计算机从队列中读取序列化交易（小心地），使用适当的密钥应用签名，并将它们放在传出队列中。传出队列将签名的交易传输到具有以太坊客户端的计算机，该客户端将它们出列并发送它们。

[[tx_propagation]]
=== 交易传播

以太坊网络使用“flood routing”协议。每个以太坊客户端充当对等（P2P）网络中的节点，其（理想地）形成网状网络。没有网络节点是特殊的：它们都充当平等对等体。我们将使用术语“节点（node）”来指代连接到并参与对等网络的以太坊客户端。

交易传播从始发的以太坊节点创建（或从离线接收）签名的交易开始。验证交易，然后将其传输到直接连接到始发节点的所有其他以太坊节点。平均而言，每个以太坊节点都保持与至少13个其他节点（称为其邻居）的连接。每个邻居节点在收到交易后立即对其进行验证。如果它们同意它是有效的，它们会存储一份副本并将其传播给所有邻居（除了它来自的邻居）。结果，交易从始发节点向外波动，像洪水一样充溢在网络中，直到网络中的所有节点都具有交易的副本。节点可以过滤它们传播的消息，但默认情况下是传播它们收到的所有有效交易消息。

在几秒钟内，以太坊交易就会传播到全球所有以太坊节点。从每个节点的角度来看，不可能辨别交易的起源。将这笔交易发送到节点的邻居可能是交易的发起者，或者可能是从其邻居之一接收到了这笔交易。为了能够跟踪交易的起源或干扰传播，攻击者必须控制所有节点的很大一部分。这是P2P网络的安全和隐私设计的一部分，特别是应用于区块链网络。

[[chain_record]]
=== 记录在区块链上

虽然以太坊中的所有节点都是相同的对等节点，但其中一些节点是由矿工操作的，并且正在向矿场提供交易和区块，矿场是具有高性能图形处理单元（GPU）的计算机。矿工计算机将交易添加到候选区块并尝试找到使候选区块有效的工作量证明。我们将在<<consensus>>中更详细地讨论这个问题。

在不进入太多细节的情况下，有效交易最终将被包含在交易的一个区块中，并因此记录在以太坊区块链中。一旦开采成区块，交易也会通过修改账户余额（在简单支付的情况下）或通过调用改变其内部状态的合约来修改以太坊单例的状态。这些变化以交易收据的形式与交易一起记录，交易收据也可能包括事件event。我们将在<<evm_chapter>>中更详细地研究所有这些。

交易已完成从创建到被EOA签字，传播和最终挖矿的过程，改变了以太坊单例的状态，并在区块链上留下了不可磨灭的印记。

=== 多重签名（Multisig）交易

如果你熟悉比特币的脚本功能，你就知道可以创建一个比特币multisig帐户，只有当多方签署交易时才能花费资金（例如，2个签名中的2个或4个中的3个）。以太坊的基本EOA价值交易没有多个签名的规定;但是，任意签名限制都可以通过智能合约强制执行，具有你能想到的任何条件，以处理ether和通证的转移。

为了利用这种能力，ether必须被转移到“钱包合约”，该合约根据所需的支出规则进行编程，例如多重签名要求或支出限额（或两者的组合）。一旦满足支出条件，钱包合约在授权的EOA提示时发送资金。例如，要在多重签名条件下保护你的ether，请将ether转移到多重合约。每当你想要将资金发送到另一个帐户时，所有必需的用户都需要使用常规钱包应用程序向合约发送交易，从而有效地授权合约执行最终交易。

这些合约还可以设计为在执行本地代码之前需要多个签名或触发其他合约。该方案的安全性最终由multisig合约代码决定。

将多重签名交易实现为智能合约的能力证明了以太坊的灵活性。然而，这是一把双刃剑，因为额外的灵活性可能导致破坏多重签名方案安全性的漏洞。事实上，有许多提议要在EVM中创建多重签名命令，以消除对智能合约的需求，至少对于简单的M-of-N多重签名方案而言。这相当于比特币的多重签名系统，它是核心共识规则的一部分，并且已被证明是健壮和安全的。

=== 总结

交易是以太坊系统中每项活动的起点。交易是导致以太坊虚拟机执行合约，更新余额以及更一般地说修改以太坊区块链状态的“输入”。接下来，我们将更详细地学习智能合约，并学习如何使用Solidity面向合约的语言进行编程。
