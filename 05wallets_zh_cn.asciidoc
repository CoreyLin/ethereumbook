[[wallets_chapter]]
== 钱包

“钱包”这个词用来描述以太坊中的一些不同的东西。

在较高级别，钱包是一个软件应用程序，作为以太坊的主要用户界面。钱包控制对用户资金的访问，管理密钥和地址，跟踪余额以及创建和签署交易。此外，一些以太坊钱包也可以与合约互动，例如ERC20通证。

从狭义的层面讲，从程序员的角度来看，钱包这个词指的是用于存储和管理用户密钥的系统。每个钱包都有一个密钥管理组件。对于一些钱包，这就是全部。其他钱包是更广泛范畴的一部分，浏览器的范畴，它们是基于以太坊的去中心化应用程序或DApps的接口，我们将在<<decentralized_applications_chap>>中更详细地研究它们。在钱包一词下混淆的各种类别之间没有明确的区别。

在本章中，我们将把钱包看作私钥的容器，以及管理这些密钥的系统。

[[wallet_tech_overview]]
=== 钱包技术概述

在本节中，我们总结了用于构建用户友好，安全且灵活的以太坊钱包的各种技术。

设计钱包的一个关键考虑因素是平衡便利性和隐私性。最方便的以太坊钱包是一个带有一个私钥和地址的钱包，可以重复使用。不幸的是，这样的解决方案是隐私噩梦，因为任何人都可以轻松跟踪和关联你的所有交易。为每笔交易使用一个新密钥对隐私最有利，但变得非常难以管理。正确的平衡很难实现，但这就是为什么优质钱包设计至关重要。

关于以太坊的一个常见误解是，以太坊钱包包含ether或通证。事实上，非常严格地说，钱包只持有密钥。ether或其他通证被记录在以太坊区块链上。用户通过在钱包中使用密钥对交易进行签名来控制网络上的通证。从某种意义上说，一个以太坊钱包是一个密钥链。话虽如此，鉴于钱包持有的密钥是将ether或通证转让给他人所需的唯一东西，实际上这种区别是相当无关紧要的。重要的区别在于改变一个人的心态，从处理传统银行业务的中心化系统（只有你和银行可以看到你账户中的资金，而你只需说服银行你要将资金转移来创建一笔交易）到去中心化区块链平台系统（每个人都可以看到一个账户的ether余额，尽管他们可能不知道账户的所有者，并且每个人都需要确信账户所有者想为要实施的交易转移资金）。在实践中，这意味着有一种独立的方式来检查一个帐户的余额，而不需要该账户的钱包。此外，如果你不喜欢你一开始使用的钱包应用，你可以将你的帐户处理从当前钱包转移到另一个不同的钱包。

[NOTE]
====
以太坊钱包包含密钥，而不是ether或通证。钱包就像包含私钥和公钥对的密钥链。用户使用私钥对交易进行签名，从而证明他们拥有ether。ether存储在区块链中。
====

有两种主要类型的钱包，区别在于它们包含的密钥是否相互关联。

第一种类型是非确定性钱包，其中每个密钥是从不同的随机数独立生成的。密钥彼此无关。这种类型的钱包也被称为JBOK钱包，来自短语“Just a Bunch of Keys”（只是一串密钥）。

第二种类型的钱包是确定性钱包，其中所有密钥都来源于一个主密钥，称为种子。这种类型的钱包中的所有密钥彼此相关，并且如果具有原始种子，则可以被再次生成。确定性钱包中使用了许多不同的密钥派生方法。最常用的派生方法使用树状结构，如<<hd_wallets>>中所述。

为了使确定性钱包更安全，防止数据丢失事故，例如手机被盗或丢弃在厕所中，种子通常被编码为单词列表（英语或其他语言）供你记下并使用在发生事故时。这些被称为钱包的助记词。当然，如果有人掌握了你的助记词，那么他们也可以重新创建你的钱包，从而获得你的ether和智能合约的访问权限。因此，对你的恢复单词列表（助记词）非常非常小心！切勿将其以电子方式存储在文件中，计算机或手机上。将其写在纸上并存放在安全可靠的地方。

接下来的几节将从较高视角介绍这些技术。


[[random_wallet]]
==== 非确定性（随机）钱包

在第一个以太坊钱包（为以太坊预售而产生）中，每个钱包文件存储了一个随机生成的私钥。这种钱包正在被确定性的钱包所取代，因为这些“旧式”钱包在许多方面都很差。例如，防止以太坊地址重用作为使用以太坊时最大化隐私的一部分被认为是一种最佳实践，即每次接收资金时使用一个新地址（需要一个新的私钥）。你可以更进一步，为每笔交易使用一个新地址，但如果你使用通证进行大量处理，这可能会变得昂贵。要遵循这种实践，非确定性钱包需要定期增加其密钥列表，这意味着你需要定期备份。如果你在设法备份钱包之前丢失了数据（磁盘故障，饮酒事故，电话被盗），你将无法访问资金和智能合约。 “0型”非确定性钱包是最难处理的，因为它们以“及时”的方式为每个新地址创建一个新的钱包文件。

然而，许多以太坊客户端（包括geth）使用keystore文件，这是一个JSON编码的文件，包含一个（随机生成的）私钥，用密码加密以提高安全性。JSON文件的内容如下所示：

[[keystore_example]]
[source,json]
----
{
    "address": "001d3f1ef827552ae1114027bd3ecf1f086ba0f9",
    "crypto": {
        "cipher": "aes-128-ctr",
        "ciphertext":
            "233a9f4d236ed0c13394b504b6da5df02587c8bf1ad8946f6f2b58f055507ece",
        "cipherparams": {
            "iv": "d10c6ec5bae81b6cb9144de81037fa15"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "dklen": 32,
            "n": 262144,
            "p": 1,
            "r": 8,
            "salt":
                "99d37a47c7c9429c66976f643f386a61b78b97f3246adca89abe4245d2788407"
        },
        "mac": "594c8df1c8ee0ded8255a50caf07e8c12061fd859f4b7c76ab704b17c957e842"
    },
    "id": "4fcb2ba4-ccdb-424f-89d5-26cce304bf9c",
    "version": 3
}
----

keystore格式使用密钥派生函数（KDF），也称为密码拉伸算法，可防止暴力，字典和彩虹表攻击。简单来说，私钥不直接通过密码加密。相反，通过反复对密码进行哈希来拉伸密码。哈希函数重复262,144轮，可以在keystore JSON中看作参数crypto.kdfparams.n。试图暴力破解密码的攻击者必须对每个尝试过的密码应用262,144轮哈希，这充分减缓了攻击，使其对于足够复杂和长度的密码不可行。

有许多软件库可以读写keystore格式，例如JavaScript的库 https://github.com/ethereumjs/keythereum[+keythereum+] 。

[TIP]
====
除了简单测试之外，不鼓励使用不确定性钱包。除了最基本的情况之外，它们太难以备份和使用。相反，使用带有助记种子的基于行业标准的HD钱包进行备份。
====

[[deterministic_wallets]]
==== 确定性（种子）钱包

确定性或“种子”钱包是包含私钥的钱包，所有私钥都来自单个主密钥或种子。种子是随机生成的数字，与其他数据组合，例如索引号或“链码”（请参阅<<extended_keys>>），以派生任意数量的私钥。在确定性钱包中，种子足以恢复所有派生的密钥，因此在创建时单个备份足以保护钱包中的所有资金和智能合约。种子也足以用于钱包导出或导入，允许在不同钱包实现之间轻松迁移所有密钥。

这种设计使种子的安全性变得至关重要，因为只需要种子就可以访问整个钱包。另一方面，能够将安全性工作集中在单个数据上可以被视为一个优势。

[[hd_wallets]]
==== 分层确定性钱包（BIP-32 / BIP-44）

确定性钱包被开发以便于从单个种子中派生出许多密钥。目前，最先进的确定性钱包形式是由比特币的 https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki[_BIP-32 standard_] 定义的分层确定性（HD）钱包。 HD钱包包含在树结构中派生出的密钥，使得父密钥可以导出一系列子密钥，每个子密钥可以导出一系列孙密钥，等等。这种树结构在<<hd_wallets_figure>>中进行了阐述。

[[hd_wallets_figure]]
.HD wallet: a tree of keys generated from a single seed
image::images/hd_wallet.png["HD wallet"]

HD钱包比简单的确定性钱包提供了一些关键优势。首先，树结构可用于表达额外的组织含义，例如子密钥的特定分支用于接收传入支付，并且使用不同分支来接收来自传出支付的更改。密钥分支也可以在公司设置中使用，将不同的分支分配给部门，子公司，特定功能或会计类别。

HD钱包的第二个优势是用户可以创建一系列公钥而无需访问相应的私钥。这允许HD钱包在不安全的服务器上使用，或者在仅观察或仅接收的容量中使用，其中钱包没有可以花费资金的私钥。

[[mnemonic_codes]]
==== 种子和助记符代码（BIP-39）

有许多方法可以对私钥进行编码以进行安全备份和检索。当前优选的方法是使用一系列单词，当以正确的顺序组合在一起时，可以唯一地重新创建私钥。这有时被称为助记词，并且该方法已由 https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki[BIP-39] 标准化。如今，许多以太坊钱包（以及其他加密货币的钱包）都使用此标准，并且可以使用可互操作的助记词导入和导出种子以进行备份和恢复。

要了解为什么这种方法变得流行，让我们来看一个例子：

[[hex_seed_example]]
.确定性钱包的一个种子，十六进制
----
FCCF1AB3329FD5DA3DA9577511F8F137
----

[[mnemonic_seed_example]]
.确定性钱包的一个种子，来自12个单词的助记词
----
wolf juice proud gown wool unfair
wall cliff insect more detail hub
----

实际上，写下十六进制序列时出错的可能性高得令人无法接受。相比之下，已知单词列表很容易处理，主要是因为单词（尤其是英语单词）的写作存在高度冗余。如果意外记录了“inzect”，则可以在需要钱包恢复时迅速确定“inzect”不是有效的英文单词，而应该使用“insect”代替。我们正在谈论写下种子的一种表示，因为这是管理HD钱包时的好习惯：在数据丢失的情况下（无论是通过事故还是盗窃）需要种子来恢复钱包，因此保持备份是非常谨慎的。但是，种子必须保持非常私密，因此应该小心避免数字备份;因此早期建议使用笔和纸进行备份。

总之，使用恢复单词列表对HD钱包的种子进行编码是最简单的方法，可以安全地导出，转录，记录在纸上，无错误地读取，并将私钥集导入另一个钱包。


[[wallet_best_practices]]
=== 钱包的最佳实践

随着加密货币钱包技术的成熟，出现了一些通用的行业标准，使得钱包具有广泛的互操作性，易于使用，安全和灵活。这些标准还允许钱包为多种不同的加密货币派生密钥，所有这些都来自一个助记词。这些共同标准是：

* 助记码词，基于BIP-39
* HD钱包，基于BIP-32
* 多用途HD钱包结构，基于BIP-43
* 多币种和多帐户钱包，基于BIP-44
这些标准可能会因未来的发展而改变或被淘汰，但目前它们形成了一系列联锁技术，这些技术已成为大多数区块链平台及其加密货币的事实上的钱包标准。

这些标准已被广泛的软件和硬件钱包所采用，使所有这些钱包都可以互操作。用户可以导出在其中一种钱包中生成的助记词，并将其导入另一种钱包，恢复所有密钥和地址。

支持这些标准的软件钱包的一些示例包括（按字母顺序列出）Jaxx，MetaMask，MyCrypto和MyEtherWallet（MEW）。支持这些标准的硬件钱包示例包括Keepkey，Ledger和Trezor。

以下部分详细介绍这些技术。

[TIP]
====
如果你正在实现以太坊钱包，它应该构建为HD钱包，种子编码为备用助记词，遵循BIP-32，BIP-39，BIP-43和BIP-44标准，如以下部分所述。
====

[[bip39]]
[[mnemonic_code_words]]
==== 助记码词（BIP-39）

助记码词是对用作种子的随机数进行编码的单词序列，以派生出确定性钱包。这个单词序列足以重新创建种子，并从那里重新创建钱包和所有派生的密钥。实现具有助记词的确定性钱包的钱包应用程序将在首次创建钱包时向用户显示12到24个单词的序列。这一系列单词是钱包备份，可用于恢复和重新创建相同或任何兼容的钱包应用程序中的所有密钥。正如我们之前解释的那样，助记词列表使用户更容易备份钱包，因为它们易于阅读和正确转录。

[NOTE]
====
助记词通常与“brainwallet”相混淆。它们不一样。主要区别在于brainwallet由用户选择的单词组成，而助记词由钱包随机创建并呈现给用户。这种重要的差异使助记词更加安全，因为人类的随机性非常差。也许更重要的是，使用术语“brainwallet”表示必须记住单词，这是一个可怕的想法，以及在需要时不进行备份的方法。
====

助记码在BIP-39中定义。请注意，BIP-39是助记码标准的一种实现。有一个不同的标准，该标准有一组不同的单词，由Electrum比特币钱包使用，并且早于BIP-39。 BIP-39由Trezor硬件钱包背后的公司提出，与Electrum的实施不兼容。然而，BIP-39现在已经在数十个可互操作的实现中获得了广泛的行业支持，应该被视为事实上的行业标准。此外，BIP-39可用于生产支持以太坊的多币种钱包，而Electrum种子则不能。

BIP-39定义了助记码和种子的创建，我们将在这里分九个步骤进行描述。为清楚起见，该过程分为两部分：步骤1到6显示在<<generating_mnemonic_words>>，步骤7到9显示在<<mnemonic_to_seed>>。

[[generating_mnemonic_words]]
===== 生成助记词

钱包使用BIP-39中定义的标准化流程自动生成助记词。钱包从熵源开始，添加校验和（checksum），然后将熵映射到一个单词列表：

1. 创建一个128到256位的加密随机序列S.
2. 通过取S的SHA-256哈希的第一个S长度÷32位来创建S的校验和。
3. 将校验和添加到随机序列S的末尾。
4. 将序列和校验和的连接划分成11位的分段。
5. 将每个11位分段的值映射到来自2,048个单词的预定义字典中的单词。
6. 从单词序列创建助记码，维护顺序。

<<generating_entropy_and_encoding>>显示了如何使用熵来生成助记词。

[[generating_entropy_and_encoding]]
[role="smallerseventy"]
.Generating entropy and encoding as mnemonic words
image::images/bip39-part1.png["Generating entropy and encoding as mnemonic words"]

<<table_bip39_entropy>>显示了熵数据的大小与单词中助记码的长度之间的关系。

[[table_bip39_entropy]]
.Mnemonic codes: entropy and word length
[options="header"]
|=======
|Entropy (bits) | Checksum (bits) | Entropy *+* checksum (bits) | Mnemonic length (words)
| 128 | 4 | 132 | 12
| 160 | 5 | 165 | 15
| 192 | 6 | 198 | 18
| 224 | 7 | 231 | 21
| 256 | 8 | 264 | 24
|=======

[[mnemonic_to_seed]]
===== 从助记词到种子

助记词代表长度为128到256位的熵。然后通过使用密钥拉伸函数PBKDF2，熵被用来派生出更长（512位）的种子。生成的种子用于构建确定性钱包并派生其密钥。

密钥拉伸函数有两个参数：助记词和salt。密钥拉伸函数中的salt的目的是使得难以构建能够支持暴力攻击的查找表。在BIP-39标准中，salt具有另一个目的：它允许引入一个密码，作为保护种子的附加安全因子，我们将在<<mnemonic_passphrase>>中更详细地描述。

步骤7到9中描述的过程从上一节中描述的过程继续：

[start=7]
7. PBKDF2密钥拉伸函数的第一个参数是步骤6中产生的助记词。
8. PBKDF2密钥拉伸函数的第二个参数是salt。 salt由字符串常量“mnemonic”和可选的用户提供的密码组成。
9. PBKDF2使用HMAC-SHA512算法通过2,048轮哈希来拉伸助记词和salt参数，产生512位的值作为其最终输出。那个512位的值是种子。

<<mnemonic_to_seed_figure>>显示了如何使用助记词来生成种子。

[[mnemonic_to_seed_figure]]
.From mnemonic to seed
image::images/bip39-part2.png["From mnemonic to seed"]

[NOTE]
====
具有2,048轮哈希的密钥拉伸函数可有效防止对助记词或密码的暴力攻击。它使得尝试超过几千个密码和助记词组合成本很高（在计算中），而可能派生的种子的数量是巨大的（2^512^，或大约10^154^） - 比可见宇宙中的原子数量大（约10^80^）。
====

表 pass:[<a data-type="xref" data-xrefstyle="select:labelnumber" href="#mnemonic_128_no_pass">#mnemonic_128_no_pass</a>, <a data-type="xref" data-xrefstyle="select:labelnumber" href="#mnemonic_128_w_pass">#mnemonic_128_w_pass</a>, 和 <a data-type="xref" data-xrefstyle="select:labelnumber" href="#mnemonic_256_no_pass">#mnemonic_256_no_pass</a>] 显示了助记码及其产生的种子的一些例子。

[[mnemonic_128_no_pass]]
.128-bit entropy mnemonic code, no passphrase, resulting seed
[cols="h,"]
|=======
| *Entropy input (128 bits)*| +0c1e24e5917779d297e14d45f14e1a1a+
| *Mnemonic (12 words)* | +army van defense carry jealous true garbage claim echo media make crunch+
| *Passphrase*| (none)
| *Seed  (512 bits)* | +5b56c417303faa3fcba7e57400e120a0ca83ec5a4fc9ffba757fbe63fbd77a89a1a3be4c67196f57c39+
+a88b76373733891bfaba16ed27a813ceed498804c0570+
|=======

[[mnemonic_128_w_pass]]
.128-bit entropy mnemonic code, with passphrase, resulting seed
[cols="h,"]
|=======
| *Entropy input (128 bits)*| +0c1e24e5917779d297e14d45f14e1a1a+
| *Mnemonic (12 words)* | +army van defense carry jealous true garbage claim echo media make crunch+
| *Passphrase*| SuperDuperSecret
| *Seed  (512 bits)* | +3b5df16df2157104cfdd22830162a5e170c0161653e3afe6c88defeefb0818c793dbb28ab3ab091897d0+
+715861dc8a18358f80b79d49acf64142ae57037d1d54+
|=======


[[mnemonic_256_no_pass]]
.256-bit entropy mnemonic code, no passphrase, resulting seed
[cols="h,"]
|=======
| *Entropy input (256 bits)* | +2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c+
| *Mnemonic (24 words)* | +cake apple borrow silk endorse fitness top denial coil riot stay wolf
luggage oxygen faint major edit measure invite love trap field dilemma oblige+
| *Passphrase*| (none)
| *Seed (512 bits)* | +3269bce2674acbd188d4f120072b13b088a0ecf87c6e4cae41657a0bb78f5315b33b3a04356e53d062e5+
+5f1e0deaa082df8d487381379df848a6ad7e98798404+
|=======

[[mnemonic_passphrase]]
===== BIP-39中的可选密码

BIP-39标准允许在种子的派生中使用可选的密码。如果没有使用密码，则使用由常量字符串“mnemonic”组成的salt来延长助记词，从任何给定的助记词产生特定的512位种子。如果使用密码，则拉伸函数会产生与该相同助记词不同的种子。实际上，给定单个助记词，每个可能的密码都会导致不同的种子。基本上，没有“错误的”密码。所有的密码都是有效的，它们都会导致生成不同的种子，形成一大堆可能未初始化的钱包。一组可能的钱包个数是如此之大（2^512^），只要密码具有足够的复杂性和长度，就没有对正在使用的钱包进行实际可能的暴力破解或意外猜测的可能。

[TIP]
====
BIP-39中没有“错误”的密码。每个密码都会导致一个钱包，除非之前使用过，否则将为空。
====

可选的密码创建了两个重要功能：

* 第二个因素（记忆的东西）使助记词本身无用，保护助记词备份免受小偷的攻击。

* 一种似是而非的否认或“胁迫的钱包”，其中所选择的密码导致带有少量资金的钱包，用于分散攻击者对包含大部分资金的“真实”钱包的注意力。

但是，重要的是要注意使用密码还是会带来丢失的风险：

* 如果钱包所有者无行为能力或死亡并且没有其他人知道密码，则种子无用，并且存储在钱包中的所有资金将永远丢失。

* 相反，如果所有者在与种子相同的位置备份密码，则会违背第二个因素的目的。

虽然密码非常有用，但它们应该只与精心规划的备份和恢复过程结合使用，考虑到继承人能够恢复加密货币的可能性。

[[working_mnemonic_codes]]
===== 使用助记码

BIP-39作为许多不同编程语言的库实现。例如：

https://github.com/trezor/python-mnemonic[python-mnemonic]:: SatoshiLabs团队在Python中提出BIP-39的标准参考实现

https://github.com/ConsenSys/eth-lightwallet[ConsenSys/eth-lightwallet]:: 用于节点和浏览器的轻量级JS以太坊钱包（使用BIP-39）

https://www.npmjs.com/package/bip39[npm/bip39]:: 比特币BIP-39的JavaScript实现：用于生成确定性密钥的助记码

还有一个BIP-39生成器在一个独立的网页（<<a_bip39_generator_as_a_standalone_web_page>>）中实现，这对测试和实验非常有用。 https://iancoleman.io/bip39/[Mnemonic Code Converter] 生成助记词，种子和扩展私钥。它可以在浏览器中脱机使用，也可以在线访问。

[[a_bip39_generator_as_a_standalone_web_page]]
.A BIP-39 generator as a standalone web page
image::images/bip39_web.png["BIP-39 generator web-page"]

[[create_hd_wallet]]
==== 从种子创建一个HD钱包

HD钱包是从单个根种子创建的，该种子是128位，256位或512位随机数。最常见的是，这种种子是由助记词生成的，如上一节所述。

HD钱包中的每个密钥都是从这个根种子确定性地派生的，这使得可以在任何兼容的HD钱包中从该种子重新创建整个HD钱包。这样，只需传输从中派生出根种子的助记词，即可轻松导出，备份，恢复和导入包含数千甚至数百万个密钥的HD钱包。

[[bip32_bip43_44]]
==== HD钱包（BIP-32）和路径（BIP-43/44）

大多数HD钱包都遵循BIP-32标准，该标准已成为确定性密钥生成的事实上的行业标准。

我们不会在这里讨论BIP-32的所有细节，只讨论了解如何在钱包中使用BIP-32所需的组件。主要的重要方面是派生密钥可能拥有的树状层次关系，正如你在<<hd_wallets_figure>>中看到的。理解扩展密钥和强化密钥的思想也很重要，这将在以下各节中进行说明。

在许多软件库中提供了许多可互操作的BIP-32实现。这些主要为比特币钱包而设计，它们以不同的方式实现地址，但与以太坊的兼容BIP-32的钱包共享相同的密钥派生实现。使用 https://github.com/ConsenSys/eth-lightwallet[专为以太坊设计] 的一个钱包，或通过添加以太坊地址编码库从比特币中改编一个。

还有一个BIP-32生成器作为 http://bip32.org/[独立的网页实现] ，对于BIP-32的测试和实验非常有用。

[WARNING]
====
这个独立的BIP-32生成器不是HTTPS站点。这是为了提醒你使用此工具并不安全。它仅用于测试。你不应该使用本网站生成的密钥用于真实资金。
====

[[extended_keys]]
===== 扩展的公钥和私钥

在BIP-32术语中，密钥可以被“扩展”。通过正确的数学运算，这些被扩展的“父”密钥可用于派生“子”密钥，从而产生前面描述的密钥和地址的层次结构。父密钥不一定必须位于树的顶部。它可以从树层次结构的任何地方挑选出来。扩展一个密钥包括获取密钥本身并追加一个特殊的链码。链码是256位二进制串，其与每个密钥混合以生成子密钥。

如果密钥是一个私钥，它成为由前缀xprv区分的扩展私钥：

[[xprv_example]]
----
xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4UxFVSfZ8n7ESu7fgir8i...
----

一个扩展公钥由前缀xpub区分：

[[xpub_example]]
----
xpub661MyMwAqRbcEnKbXcCqD2GT1di5zQxVqoHPAgHNe8dv5JP8gWmDproS6kFHJnLZd23tWevhdn...
----

HD钱包的一个非常有用的特性是能够从父公钥派生出子公钥而无需私钥。这为我们提供了两种方法来派生子公钥：直接来自子私钥，或者来自父公钥。

因此，可以使用扩展公钥来派生出HD钱包结构的该分支中的所有公钥（仅公钥）。

此快捷方式可用于创建非常安全的仅包含公钥的部署，其中服务器或应用程序具有一个扩展公钥的副本，但不包含任何私钥。这种部署可以产生无限数量的公钥和以太坊地址，但不能发送任何钱到这些地址。同时，在另一个更安全的服务器上，扩展私钥可以导出所有相应的私钥以签署交易并花钱。

此方法的一个常见应用是在服务于电子商务应用程序的Web服务器上安装扩展公钥。 Web服务器可以使用公钥派生功能为每笔交易（例如，对于一个客户购物车）创建一个新的以太坊地址，并且将不具有任何易受盗窃的私钥。如果没有HD钱包，唯一的方法是在单独的安全服务器上生成数千个以太坊地址，然后在电子商务服务器上预加载它们。这种方法很麻烦，需要不断维护以确保服务器不会耗尽密钥，因此优先使用HD钱包中的扩展公钥。

该解决方案的另一个常见应用是用于冷藏或硬件钱包。在这种场景下，扩展私钥可以存储在硬件钱包中，而扩展公钥可以保持在线。用户可以随意创建“接收”地址，而私钥可以安全地离线存储。为了花费资金，用户可以在脱机签名以太坊客户端中使用扩展私钥，或者在硬件钱包设备上签署交易。

[[hardened_child_key]]
===== 强化子密钥派生

从一个扩展公钥或xpub派生公钥分支的能力非常有用，但它带来了潜在的风险。访问一个xpub不允许访问子私钥。但是，因为xpub包含链码（用于从父公钥派生子公钥），如果一个子私钥已知或以某种方式泄露，它可以与链码一起使用以派生所有其他子私钥。单个泄露的子私钥与父链码一起可以推导出所有子私钥。更糟糕的是，子私钥和父链码可用于推导父私钥。

为了应对这种风险，HD钱包使用一种称为强化派生的替代派生函数，该函数“打破”父公钥和子链码之间的关系。强化派生函数使用父私钥来派生子链码，而不是父公钥。这会在父/子序列中创建一个“防火墙”，其链码不能用于破坏父代或兄弟私钥。

简单来说，如果你希望使用xpub的便利来派生公钥的分支而不让自己暴露于泄露的链码的风险，那么你应该从强化的父代而不是普通的父代派生它。最佳实践是使主密钥的1级子密钥始终通过强化派生派生，以防止损坏主密钥。

[[index_number]]
===== 正常和硬化派生的索引号

能够从给定的父密钥派生出多个子密钥显然是可取的。要管理它，使用索引号。每个索引号当与使用特殊子派生函数的父密钥组合时，给出不同的子密钥。 BIP-32父到子派生函数中使用的索引号是32位整数。为了容易区分通过正常（未强化）派生函数派生的密钥与通过强化派生函数派生的密钥，该索引号被分成两个范围。 0到2^31^（0x0到0x7FFFFFFF）之间的索引号仅用于正常派生。 2^31^和2^32^之间的索引号（0x80000000至0xFFFFFFFF）仅用于硬化派生。因此，如果索引号小于231，则子密钥是正常的，而如果索引号等于或大于231，则子密钥是强化的。

为了使索引号更易于阅读和显示，强化子密钥的索引号从零开始显示，但带有一个素数符号。因此，第一个普通子密钥显示为0，而第一个硬化子密钥（索引0x80000000）显示为0＆＃x27;。然后，按顺序，第二个强化密钥的索引为0x80000001，并显示为1＆＃x27;，依此类推。当你看到HD钱包索引i＆＃x27;时，这意味着2^31^ + i。

[[hd_wallet_path]]
===== HD钱包密钥标识符（路径）

HD钱包中的密钥使用“路径”命名约定来标识，树的每个级别用斜杠（/）字符分隔（请参阅<<hd_path_table>>）。从主私钥派生的私钥以m开头。从主公钥派生的公钥以M开头。因此，主私钥的第一个子私钥是m/0。第一个子公钥是M/0。第一个孩子的第二个孙子是m/0/1，依此类推。

从右到左读取密钥的“祖先”，直到你到达从中导出密钥的主密钥。例如，标识符m/x/y/z描述了密钥m/x/y的第z个子密钥，它是密钥m/x的第y个子密钥，它是m的第x个子密钥。

[[hd_path_table]]
.HD wallet path examples
[options="header"]
|=======
|HD path | Key described
| +m/0+ | The first (+0+) child private key of the master private key (+m+)
| +m/0/0+ | The first grandchild private key of the first child (+m/0+)
| +m/0'/0+ | The first normal grandchild of the first _hardened_ child (+m/0'+)
| +m/1/0+ | The first grandchild private key of the second child (+m/1+)
| +M/23/17/0/0+ | The first great-great-grandchild public key of the first great-grandchild of the 18th grandchild of the 24th child
|=======

[[navigating_hd_wallet_tree]]
===== 导航HD钱包树结构

HD钱包树结构非常灵活。另一方面，它还允许无限复杂性：每个父扩展密钥可以有40亿子密钥：20亿正常子密钥和20亿强化子密钥。这些子密钥中的每一个都可以有另外40亿个子密钥，依此类推。树可以像你想要的那样深，可能有无数代。有了这些潜力，导航这些非常大的树变得非常困难。

两个BIP通过为HD钱包树的结构创建标准，提供了一种管理这种潜在复杂性的方法。 BIP-43建议使用第一个强化子索引作为表示树结构“目的”的特殊标识符。基于BIP-43，HD钱包应该只使用树的一个1级分支，其索引号通过识别树的其余部分的结构和命名空间来定义钱包的目的。更具体地说，仅使用分支m/i&#x27;/...的HD钱包旨在表示特定目的，并且该目的由索引号i标识。

扩展该规范，BIP-44提出了一种多币种多帐户结构，通过将“目的”数字设置为44'来表示。遵循BIP-44结构的所有HD钱包都通过以下事实来识别：它们仅使用树的一个分支：m/44'/*。

BIP-44将结构指定为由五个预定义树级组成：

[[bip44_tree]]
-----
m / purpose' / coin_type' / account' / change / address_index
-----

第一级，purpose &#x27;，始终设置为44&#x27;。第二级，coin_type &#x27;，指定加密货币的类型，允许多币种HD钱包，其中每种货币在第二级别下具有自己的子树。标准文件 https://github.com/satoshilabs/slips/blob/master/slip-0044.md[SLIP0044] 中定义了几种货币;例如，以太坊是m/44&#x27;/60&#x27;，以太坊经典是m/44&#x27;/61&#x27;,比特币是m/44&#x27;/0&#x27;,和所有的Testnet货币是m/44&#x27;/1&#x27;。

树的第三层是account &#x27;，它允许用户将其钱包细分为单独的逻辑子帐户，以用于会计或组织目的。例如，一个HD钱包可能包含两个以太坊“帐户”：m/44&#x27;/60&#x27;/0&#x27; 和 m/44&#x27;/60&#x27;/1&#x27;。每个帐户都是其子树的根。

因为BIP-44最初是为比特币创建的，所以它包含一个与以太坊世界无关的“怪癖”。在路径的第四级，change，HD钱包有两个子树：一个用于创建接收地址，另一个用于创建更改地址。在以太坊中只使用“接收”路径，因为没有像比特币那样需要更改地址。请注意，虽然之前的层级使用了强化派生，但此层级使用常规派生。这是为了允许树的account层级导出扩展公钥以在非安全环境中使用。可用地址由HD钱包作为第四层级的子级派生，生成树的第五层级address_index。例如，主帐户中以太坊支付的第三个接收地址为M/44&#x27;/60&#x27;/0&#x27;/0/2。<<bip44_path_examples>>显示了更多示例。

[[bip44_path_examples]]
.BIP-44 HD wallet structure examples
[options="header"]
|=======
|HD path | Key described
| ++M/44&#x27;/60&#x27;/0&#x27;/0/2++ | The third receiving public key for the primary Ethereum account
| ++M/44&#x27;/0&#x27;/3&#x27;/1/14++ | The 15^th^ change-address public key for the 4^th^ Bitcoin account
| ++m/44&#x27;/2&#x27;/0&#x27;/0/1++ | The second private key in the Litecoin main account, for signing transactions
|=======

=== 总结

钱包是任何面向用户的区块链应用程序的基础。它们允许用户管理密钥和地址的集合。钱包还允许用户通过应用数字签名来证明他们对ether的所有权，并授权交易，我们将在<<tx_chapter>>中看到。
