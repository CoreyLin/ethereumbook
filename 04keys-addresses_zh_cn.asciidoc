[[keys_addresses]]
== 密码学

以太坊的基础技术之一是密码学，它是计算机安全中广泛使用的数学分支。密码学在希腊语中意为“保密信件”，但密码学的研究不仅包括保密信件，也称为加密。例如，密码学也可用于证明秘密的知识而不揭示该秘密（例如，用数字签名），或证明数据的真实性（例如，用数字指纹，也称为“哈希”）。这些类型的加密证明是对以太坊平台（实际上是所有区块链系统）的操作至关重要的数学工具，并且也广泛用于以太坊应用程序中。请注意，在发布时，以太坊协议的任何部分都不涉及加密;也就是说，与以太坊平台和节点之间的所有通信（包括交易数据）都是未加密的，任何人都可以（必然）阅读。这样每个人都可以验证状态更新的正确性，并达成共识。将来，将提供高级加密工具，例如零知识证明和同态加密，这些工具将允许一些加密计算记录在区块链上，同时仍能实现共识;然而，虽然它们已经被预知，但尚未部署。在本章中，我们将介绍以太坊中使用的一些密码学：即公钥密码学（PKC），用于以私钥和地址的形式控制资金的所有权。

[[keys_addresses_intro]]
=== 密钥和地址

正如我们在本书前面所看到的，以太坊有两种不同类型的账户：外部拥有账户（EOA）和合约。 EOA的ether所有权是通过数字私钥，以太坊地址和数字签名建立的。私钥是所有用户与以太坊互动的核心。实际上，帐户地址直接来自于私钥：私钥唯一地确定单个以太坊地址，也称为帐户。

私钥不以任何方式直接在以太坊系统中使用;它们永远不会传输或存储在以太坊上。也就是说私钥应该保持私有，永远不会出现在传递给网络的消息中，也不应该存储在链上;只有帐户地址和数字签名才会传输并存储在以太坊系统中。有关如何保护私钥安全的详细信息，请参阅<<control_responsibility>>和<<wallets_chapter>>。

使用数字签名实现对资金的访问和控制，数字签名也是由私钥创建的。以太坊交易要求一个有效的数字签名包含在区块链中。拥有私钥副本的任何人都可以控制相应的帐户及其拥有的所有ether。假设用户保持其私钥安全，以太坊交易中的数字签名证明了资金的真正所有者，因为它们证明了私钥的所有权。

在基于公钥密码学的系统中，例如以太坊使用的系统，密钥成对出现，包括一个私有（秘密）密钥和一个公钥。将公钥视为与银行帐号相似，私钥与秘密的PIN类似;后者提供对帐户的控制，而前者则为其他人识别。私钥本身很少被以太坊用户看到;在大多数情况下，它们以加密形式存储在特殊文件中，并由以太坊钱包软件管理。

在以太坊交易的支付部分中，预期接收者由以太坊地址表示，其使用方式与银行转账的收款人帐户详细信息相同。正如我们稍后将更详细地看到的，一个EOA的以太坊地址是从密钥对的公钥部分生成的。但是，并非所有以太坊地址都代表公钥 - 私钥对;它们也可以代表合约，正如我们将在<<smart_contracts_chapter>>中看到的那样，合同不被私钥支持。

在本章的剩余部分，我们将首先更详细地探索基本密码学，并解释以太坊中使用的数学。然后我们将看看如何生成，存储和管理密钥。最后，我们将回顾用于表示私钥，公钥和地址的各种编码格式。

[[pkc]]
=== 公钥密码学和加密货币

公钥密码学（也称为“非对称加密”）是现代信息安全的一个核心部分。 20世纪70年代由Martin Hellman，Whitfield Diffie和Ralph Merkle首次发布的密钥交换协议是一项巨大的突破，引发了密码学领域的第一次公众兴趣浪潮。在20世纪70年代之前，强密码知识被政府保密。

公钥密码学使用唯一密钥来保护信息。这些密钥基于具有一个特殊属性的数学函数：它很容易计算，但很难反向计算它们。基于这些功能，密码学可以创建数字秘密和不可伪造的数字签名，这些签名受到数学定律的保护。

例如，将两个大素数相乘是很简单的。但给定两个大素数的乘积，很难找出素因子（一个称为素数因子分解的问题）。假设我们提供数字8,018,009，并告诉您它是两个素数的乘积。找到这两个素数对你来说要比将它们相乘产生8,018,009要困难得多。

如果你知道一些秘密信息，这些数学函数中的一些可以很容易地反转。在前面的例子中，如果我告诉你其中一个素因子是2,003，你可以通过简单的除法轻松找到另一个：8,018,009 ÷ 2,003 = 4,003。这些函数通常被称为trapdoor functions，因为它们很难被反转，除非你获得一条秘密信息，可用作反转函数的快捷方式。

在密码学中有用的一种更高级的数学函数类别是基于一个椭圆曲线上的算术运算。在椭圆曲线算术中，乘以模数的素数很简单，但除法（相反）实际上是不可能的。这称为离散对数问题，目前还没有已知的trapdoors。椭圆曲线密码学广泛用于现代计算机系统中，是以太坊（和其他加密货币）使用私钥和数字签名的基础。

[NOTE]
====
如果你有兴趣阅读有关密码学和现代密码学中使用的数学函数的更多信息，请查看以下资源：

* https://en.wikipedia.org/wiki/Cryptography[Cryptography]

* https://en.wikipedia.org/wiki/Trapdoor_function[Trapdoor function]

* https://en.wikipedia.org/wiki/Integer_factorization[Prime factorization]

* https://en.wikipedia.org/wiki/Discrete_logarithm[Discrete logarithm]

* https://en.wikipedia.org/wiki/Elliptic-curve_cryptography[Elliptic curve cryptography]
====

在以太坊中，我们使用公钥密码学（也称为非对称加密）来创建我们在本章中讨论的公钥 - 私钥对。它们被认为是“对”，因为公钥来自私钥。它们共同代表一个以太坊帐户，分别提供可公开访问的帐户句柄（地址）和对帐户中任何ether访问的私人控制权以及帐户在使用智能合约时所需的任何身份验证。私钥通过作为创建数字签名所需的唯一信息来控制访问，这些信息是签署交易以在帐户中花费任何资金所必需的。数字签名也用于验证合约的所有者或用户，我们将在<<smart_contracts_chapter>>中看到。

[TIP]
====
在大多数钱包实现中，为方便起见，私钥和公钥一起存储为密钥对。但是，可以从私钥容易地计算公钥，因此也可以仅存储私钥。
====

可以创建一个数字签名以对任何消息进行签名。对于以太坊交易，交易本身的详细信息将被用作消息。密码学的数学 - 在这种场景下，椭圆曲线密码学提供了一种方法，用于将消息（即，交易细节）与私钥组合以创建只能在知道私钥的情况下产生的代码。该代码称为数字签名。请注意，以太坊交易基本上是访问具有特定以太坊地址的特定帐户的请求。当一笔交易被发送到以太坊网络以便转移资金或与智能合约交互时，需要使用与所讨论的以太坊地址相对应的私钥创建的数字签名来发送交易。椭圆曲线数学意味着任何人都可以通过检查数字签名是否与交易详细信息和请求访问的以太坊地址相匹配来验证一笔交易是否有效。验证根本不涉及私钥;私钥仍然是私有的。但是，验证过程毋庸置疑地确定了交易只有可能来自具有与以太坊地址背后的公钥对应的私钥的某人。这就是公钥密码学的“神奇”。


[TIP]
====
以太坊协议没有加密的部分 - 作为以太坊网络操作的一部分发送的所有消息都可以（必然）被所有人读取。因此，私钥仅用于创建用于交易验证的数字签名。
====

[[private_keys]]
=== 私钥

一个私钥只是一个随机挑选的数字。私钥的所有权和控制权是用户控制与相应的以太坊地址相关联的所有资金的根源，以及访问授权该地址的合约的根源。私钥用于创建签名，此签名可证明一笔交易中使用的资金的所有权，所以在花费ether时需要此签名。私钥必须始终保密，因为向第三方透露私钥等同于让他们控制ether和由该私钥保护的合约。还必须备份私钥并防止意外丢失。如果它丢失了，它就无法恢复，而它所保卫的资金也会永远丢失。

[TIP]
====
以太坊私钥只是一个数字。随机选择私钥的一种方法是简单地使用一个硬币，铅笔和纸张：掷硬币256次，你就拥有了一个可以在以太坊钱包（可能 - 见下一节）中使用的随机私钥的二进制数。然后可以从私钥生成公钥和地址。
====

[[generating_private_key]]
==== 从一个随机数生成一个私钥

生成密钥的第一步也是最重要的一步是找到一个安全的熵源或随机性。创建以太坊私钥本质上涉及选择一个1到2^256^之间的数字。用于选择该数字的确切方法无关紧要，只要它是不可预测的或不确定性的。以太坊软件使用底层操作系统的随机数生成器来产生256个随机位。通常，操作系统随机数生成器由一个人类随机源初始化，这就是为什么可能会要求你将鼠标摆动几秒钟，或者按键盘上的随机键。另一种选择可能是计算机麦克风通道上的宇宙辐射噪声。

更确切地说，一个私钥可以是任何非零数字，直到略小于2^256^&#x2014的非常大的数字 - 一个巨大的78位数字，大约为1.158 * 10^77^.确切的数字与2^256^共享前38位数字并定义为以太坊中使用的椭圆曲线的顺序（参见<<elliptic_curve>>）。要创建私钥，我们会随机选择一个256位数字并检查它是否在有效范围内。在编程术语中，这通常通过将一个更大的随机位字符串（从一个加密安全的随机源收集）发送到256位哈希算法（例如Keccak-256或SHA-256）来实现，这两种算法都可以方便地生成一个256位的数字。如果结果在有效范围内，我们就有一个合适的私钥。否则，我们只需再试一下另一个随机数。

[TIP]
====
2^256^&#x2014 - 以太坊私钥空间的大小 - 是一个不可思议的大数字。它表示为十进制约10^77^;也就是说，一个77位的数字。为了比较，可见的宇宙估计包含10^80^个原子。因此，几乎有足够的私钥可以为宇宙中的每个原子提供以太坊帐户。如果你随机选择一个私钥，那么任何人都无法猜测或自己选择这个私钥。
====

请注意，私钥生成的过程是离线的;它不需要与以太坊网络进行任何通信，也不需要与任何人进行任何通信。因此，为了选择一个没有人会选择的数字，它需要是真正随机的。如果你自己选择数字，那么其他人尝试它（然后偷走你的ether）的机会太高了。使用错误的随机数生成器（如大多数编程语言中的伪随机rand函数）更糟糕，因为它更加明显，甚至更容易复制。就像在线帐户的密码一样，私钥需要是不可猜测的。幸运的是，你永远不需要记住你的私钥，因此你可以采取最佳的方法来选择它：即真正的随机性。

[WARNING]
====
不要编写自己的代码来创建一个随机数或使用编程语言提供的一个“简单”随机数生成器。使用具有足够熵源的种子的加密安全伪随机数生成器（如CSPRNG）至关重要。研究你选择的随机数生成器库的文档，以确保它是加密安全的。正确实现CSPRNG库对密钥的安全性至关重要。
====

以下是以十六进制格式显示的一个随机生成的私钥（256位显示为64个十六进制数字，每个4位）：

[[prv_key_example]]
----
f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
----


[[pubkey]]
=== 公钥

以太坊公钥是一个椭圆曲线上的一个点，意味着它是一组满足椭圆曲线方程的x和y坐标。

简单来说，一个以太坊公钥是两个连接在一起的数字。这些数字是通过只能单向计算的私钥生成的。这意味着如果你拥有私钥，则计算公钥是很容易的，但你无法从公钥计算私钥。

[WARNING]
====
MATH即将发生！不要惊慌。如果你在以下段落中的任何一点开始迷路，你可以跳过接下来的几节。有许多工具和库可供你进行数学计算。
====

使用椭圆曲线乘法从私钥计算公钥，这实际上是不可逆的：K = k * G，其中k是私钥，G是称为生成点的常数点，K是生成的公钥，并且*是特殊的椭圆曲线“乘法”运算符。请注意，椭圆曲线乘法与正常乘法不同。它与正常乘法共享功能属性，但这就是它。例如，反向操作（对于正常数字将是除法），称为“找到离散对数”-例如，如果你知道K的情况下计算k-就像尝试k的所有可能值一样困难（强力搜索k将花费比这个宇宙允许的更多时间）。

简而言之：椭圆曲线上的算术不同于“常规”整数算术。点（G）可以乘以整数（k）以产生另一个点（K）。但是没有除法之类的东西，因此不可能简单地将公钥K“除”点G来计算私钥k。这是<<pkc>>中描述的单向数学函数。

[NOTE]
====
椭圆曲线乘法是密码学家称之为“单向”函数的一种函数：它很容易在一个方向上进行（乘法）而在反向（除法）中是不可能的。私钥的所有者可以轻松地创建公钥，然后与世界共享，并且知道没有人可以反转该功能并从公钥计算私钥。这种数学技巧成为不可伪造和安全的数字签名的基础，数字签名证明了以太坊资金的所有权和合约的控制权。
====

在我们演示如何从私钥生成公钥之前，让我们更详细地看一下椭圆曲线密码学。


[[elliptic_curve]]
==== 椭圆曲线密码学解释

椭圆曲线密码学是一种基于离散对数问题的非对称或公钥密码学，如椭圆曲线的点上的加法和乘法所表示的。

<<ecc-curve>>是椭圆曲线的一个例子，类似于以太坊使用的曲线。

[NOTE]
====
以太坊使用和比特币完全相同的椭圆曲线，称为secp256k1。这使得重用比特币的许多椭圆曲线库和工具成为可能。
====

[[ecc-curve]]
[role="smallerthirty"]
.A visualization of an elliptic curve
image::images/simple_elliptic_curve.png["ecc-curve"]

以太坊使用一个特定的椭圆曲线和一组数学常数，如美国国家标准与技术研究院（NIST）建立的名为secp256k1的标准中所定义的。 secp256k1曲线由以下函数定义，该函数生成椭圆曲线：

[latexmath]
++++
\begin{equation}
{y^2 = (x^3 + 7)}~\text{over}~(\mathbb{F}_p)
\end{equation}
++++

or:

[latexmath]
++++
\begin{equation}
{y^2 \mod p = (x^3 + 7) \mod p}
\end{equation}
++++

mod p（模素数p）表示该曲线在素数阶p的有限域上，也写为\(\( \mathbb{F}_p \)\)，其中p = 2^256^ – 2^32^ – 2^9^ – 2^8^ – 2^7^ – 2^6^ – 2^4^ – 1，这是一个非常大的素数。

因为此曲线是在素数阶的有限域而不是实数上定义的，所以它看起来像是在两个维度上散布的点图案，这使得难以可视化。但是，数学与实数上的椭圆曲线相同。例如，<<ecc-over-F17-math>>在素数阶17的小得多的有限域上显示相同的椭圆曲线，显示网格上的点图案。 secp256k1以太坊椭圆曲线可以被认为是在一个不可思议的大网格上更复杂的点图案。

[[ecc-over-F17-math]]
[role="smallersixty"]
.Elliptic curve cryptography: visualizing an elliptic curve over F(p), with p=17
image::images/ec_over_small_prime_field.png["ecc-over-F17-math"]

因此，例如，以下是坐标（x，y）的点Q，它是secp256k1曲线上的一个点：

[[coordinates_example]]
----
Q = (49790390825249384486033144355916864607616083520101638681403973749255924539515,
59574132161899900045862086493921015780032175291755807399284007721050341297360)
----

<<example_1>>显示了如何使用Python自己检查这个点。变量x和y是点Q的坐标，如上所述。变量p是椭圆曲线的素数阶（用于所有模运算的素数）。 Python的最后一行是椭圆曲线方程（Python中的％运算符是模运算符）。如果x和y确实是椭圆曲线上的点的坐标，则它们满足方程并且结果为零（0L是具有值零的长整数）。自己尝试通过在命令行上键入python并从列表中复制每一行（在提示>>>之后）：

++++
<div data-type="example" id="example_1">
<h5>Using Python to confirm that this point is on the elliptic curve</h5>
<pre data-type="programlisting">
Python 3.4.0 (default, Mar 30 2014, 19:23:13)
[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> <strong>p = 115792089237316195423570985008687907853269984665640564039457584007908834671663</strong>
>>> <strong>x = 49790390825249384486033144355916864607616083520101638681403973749255924539515</strong>
>>> <strong>y = 59574132161899900045862086493921015780032175291755807399284007721050341297360</strong>
>>> <strong>(x ** 3 + 7 - y**2) % p</strong>
0L
</pre>
</div>
++++

[[EC_math]]
==== 椭圆曲线算术运算

很多椭圆曲线的数学看起来非常像我们在学校学到的整数运算。具体来说，我们可以定义一个加法运算符，它不是沿着数字线跳跃而是跳到曲线上的其他点。一旦我们有了加法运算符，我们也可以定义一个点和一个整数的乘法，这相当于重复加法。

定义椭圆曲线的加法使得在椭圆曲线上给定两个点P1和P2，在椭圆曲线上也存在第三点P3 = P1 + P2。

几何上，通过在P1和P2之间画一条线来计算该第三点P3。这条线将在一个额外的位置（令人惊讶地）与椭圆曲线相交。称此点为P3' = (x, y)。然后在x轴上反射得到P3 = (x, –y)。

如果P1和P2是相同的点，则“P1”和“P2”之间的线应该延伸到此点P1处的曲线的切线。该切线将恰好与一个新点相交。你可以使用微积分技术来确定切线的斜率。奇怪的是，这些技术仍然有效，即使我们正在限制我们对两个整数坐标的曲线上的点的兴趣！

在椭圆曲线数学中，还有一个称为“无穷远点”的点，它大致对应于数字零的作用。在计算机上，它有时用x = y = 0表示（它不满足椭圆曲线方程，但它是一个可以检查的简单单独的情况）。有几个特殊情况可以解释无限远点的必要性。

在某些情况下（例如，如果P1和P2具有相同的x值但y值不同），则该线将完全垂直，在这种情况下，P3 =无穷远处的点。

如果P1是无穷远处的点，那么P1 + P2 = P2。类似地，如果P2是无穷远处的点，那么P1 + P2 = P1。这显示了无限远处的点如何扮演零在“正常”算术中扮演的角色。

+是关联的，这意味着(A + B) + C = A + (B + C)。这意味着我们可以没有歧义地编写A + B + C（没有括号）。

现在我们已经定义了加法，我们可以用扩展加法的标准方式定义乘法。对于椭圆曲线上的点P，如果k是整数，则k * P = P + P + P + …​ + P（k次）。注意，在这种情况下，k有时（可能容易混淆地）称为“指数”。

[[public_key_derivation]]
==== 生成一个公钥

从以随机生成的数字k形式的私钥开始，我们将它乘以曲线上称为生成器点G的预定点，以在曲线上的其他位置产生另一个点，即相应的公钥K：

[latexmath]
++++
\begin{equation}
{K = k * G}
\end{equation}
++++

生成器点被指定为secp256k1标准的一部分;它对于secp256k1的所有实现都是相同的，并且从该曲线派生的所有密钥使用相同的点G.因为所有以太坊用户的生成器点始终相同，所以私钥k乘以G将始终生成相同的公钥K. k和K之间的关系是固定的，但只能在一个方向上计算，从k到K.这就是为什么以太坊地址（从K派生）可以与任何人共享并且不会泄露用户的私钥（k）。

正如我们在前一节中所描述的，k * G的乘法等效于重复加法，因此G + G + G + …​ + G，重复k次。总之，为了产生公钥K，从私钥k我们将生成器点G与其自身相加k次。

[TIP]
====
私钥可以转换为公钥，但公钥不能转换回私钥，因为此处的数学是单向的。
====

让我们应用此计算来查找我们在<<private_keys>>中显示的特定私钥的公钥：


[[example_privkey]]
.Example private key to public key calculation
----
K = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315 * G
----

加密库可以帮助我们使用椭圆曲线乘法计算K.生成的公钥K被定义为点：

----
K = (x, y)
----

其中:

----
x = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b
y = 83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
----

在以太坊中，你可能会看到公钥被表示为130个十六进制字符（65字节）的序列化。这是从高效密码学标准行业协会（SECG）提出的标准序列化格式中采用的，在 http://www.secg.org/sec1-v2.pdf[Standards for Efficient Cryptography (SEC1)] 中有记录。该标准定义了四个可能的前缀，可用于识别椭圆曲线上的点，列在<<EC_prefix_table>>中。

[[EC_prefix_table]]
.Serialized EC public key prefixes
[options="header"]
|===
| Prefix | Meaning | Length (bytes counting prefix)
| +0x00+ | Point at infinity | 1
| +0x04+ | Uncompressed point | 65
| +0x02+ | Compressed point with even +y+ | 33
| +0x03+ | Compressed point with odd +y+ | 33
|===

以太坊只使用未压缩的公钥;因此唯一相关的前缀是（十六进制）04。序列化连接公钥的x和y坐标：

[[concat_coordinates]]
----
04 + x-coordinate (32 bytes/64 hex) + y-coordinate (32 bytes/64 hex)
----

因此，我们之前计算的公钥被序列化为：

[[serialized_pubkey]]
----
046e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0 \
c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
----

[[EC_lib]]
==== 椭圆曲线库

在加密货币相关的项目中使用了几个secp256k1椭圆曲线的实现：

((("OpenSSL cryptographic library")))https://www.openssl.org/[OpenSSL]:: OpenSSL库提供了一套全面的加密原语，包括secp256k1的完整实现。例如，为了派生出公钥，可以使用函数EC_POINT_mul。

((("libsecp256k1 cryptographic library")))https://github.com/bitcoin-core/secp256k1[libsecp256k1]:: 比特币核心的libsecp256k1是secp256k1椭圆曲线和其他加密原语的C语言实现。它是从头开始编写的，用Bitcoin Core软件取代OpenSSL，在性能和安全性方面都被认为是优越的。

[[hash_functions]]
=== 加密哈希函数

在以太坊中大量使用了加密哈希函数。实际上，哈希函数在几乎所有的加密系统中都被广泛使用 - 这是密码学家 https://www.schneier.com/essays/archives/2004/08/cryptanalysis_of_md5.html[Bruce Schneier] 所捕获的事实，他说，“除了加密算法之外，单向哈希函数是现代密码学的主力。”

在本节中，我们将讨论哈希函数，探索它们的基本属性，并了解这些属性如何使它们在现代密码学的许多领域中如此有用。我们在这里提出哈希函数，因为它们是将以太坊公钥转换为地址的一部分。它们还可用于创建数字指纹，这有助于数据验证。

简单来说， https://en.wikipedia.org/wiki/Hash_function[_hash function_] 是“可用于将任意大小的数据映射到固定大小的数据的任何函数。”哈希函数的输入称为原像，消息或简称为输入数据。输出称为哈希。 https://en.wikipedia.org/wiki/Cryptographic_hash_function[_Cryptographic hash functions_] 是一个特殊的子类别，具有对安全平台（例如以太坊）有用的特定属性。

加密哈希函数是单向哈希函数，其将任意大小的数据映射到固定大小的位串。 “单向”性质意味着如果只知道输出哈希，则重新创建输入数据在计算上是不可行的。确定可能输入的唯一方法是进行暴力搜索，检查每个候选者是否匹配输出;鉴于搜索空间几乎是无限的，很容易理解任务的实际不可能性。即使你找到一些创建匹配哈希的输入数据，它也可能不是原始输入数据：哈希函数是“多对一”函数。找到哈希到同一输出的两组输入数据称为找到哈希冲突。粗略地说，哈希函数越好，哈希冲突就越少。对于以太坊来说，哈希冲突实际上是不可能的。

让我们仔细看看加密哈希函数的主要属性。这些包括：

Determinism（确定性）:: 给定的输入消息总是产生相同的哈希输出。

Verifiability（可验证）:: 计算消息的哈希是高效的（线性复杂度）。

Noncorrelation（不相关性）:: 对消息的小的改变（例如，1比特的改变）应该如此广泛地改变哈希输出，使得它不能与原始消息的哈希相关。

Irreversibility（不可逆性）:: 从哈希计算消息是不可行的，相当于通过所有可能的消息进行暴力搜索。

Collision protection（冲突保护）:: 计算出产生相同哈希输出的两个不同消息应该是不可行的。

抗哈希冲突性对于避免以太坊中的数字签名伪造尤其重要。

这些属性的组合使加密哈希函数可用于广泛的安全应用程序，包括：

* 数据指纹
* 消息完整性（错误检测）
* 工作量证明
* 身份验证（密码哈希和密钥扩展）
* 伪随机数生成器
* 消息提交（commit–reveal机制）
* 唯一标识符

随着我们在系统的各个层面上进展，我们将在以太坊中找到许多这些。

[[keccak256]]
==== 以太坊的密码哈希函数：Keccak-256

以太坊在许多地方使用Keccak-256加密哈希函数。 Keccak-256被设计为2007年由国家科学技术研究所举办的SHA-3密码哈希函数竞赛的候选者。 Keccak是获胜的算法，在2015年被标准化为联邦信息处理标准（FIPS）202。

然而，在以太坊开发期间，NIST标准化尚未最终确定。 NIST在标准流程完成后调整了Keccak的一些参数，据称是为了提高其效率。这是在英雄告密者爱德华·斯诺登透露文件的同时发生的，这些文件暗示NIST可能受到国家安全局的不当影响，故意削弱Dual_EC_DRBG随机数生成器器标准，有效地在标准随机数生成器中放置后门。这一争议的结果是对提议的变更的强烈抵制以及SHA-3标准化的显著延迟。当时，以太坊基金会决定实现其发明人提出的原始Keccak算法，而不是NIST修改的SHA-3标准。

[WARNING]
====
虽然你可能会在以太坊文档和代码中看到“SHA-3”，但很多（如果不是全部）实例实际上都是指Keccak-256，而不是最终的FIPS-202 SHA-3标准。实现差异很小，与填充参数有关，但它们的重要性在于Keccak-256为相同的输入产生与来自FIPS-202 SHA-3的不同哈希输出。
====

[[which_hash]]
==== 我正在使用哪种哈希函数？

如果两者都被称为“SHA-3”，你如何判断你使用的软件库是否实现了FIPS-202 SHA-3或Keccak-256？

一种简单的方法是使用一个测试向量，即一个给定输入的预期输出。最常用于哈希函数的测试是空输入。如果你使用空字符串作为输入运行哈希函数，你应该看到以下结果：

----
Keccak256("") =
  c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470

SHA3("") =
  a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a
----


无论调用什么函数，你都可以通过运行这个简单的测试来测试它是否是原始的Keccak-256或最终的NIST标准FIPS-202 SHA-3。请记住，以太坊使用Keccak-256，即使它在代码中通常被称为SHA-3。

[NOTE]
====
由于以太坊中使用的哈希函数（Keccak-256）与最终标准（FIP-202 SHA-3）之间的差异造成的混淆，正在努力重命名所有代码中的sha3的所有实例，操作码，和库到keccak256。有关详细信息，请参阅 https://github.com/ethereum/EIPs/issues/59[ERC59] 。
====


接下来，让我们来看看以太坊中Keccak-256的第一个应用，即从公钥生成以太坊地址。

[[eth_address]]
=== 以太坊地址

以太坊地址是使用Keccak-256单向哈希函数从公钥或合约派生的唯一标识符。

在前面的示例中，我们从私钥开始，并使用椭圆曲线乘法来派生公钥：

私钥k：

----
k = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
----

[[concat_pubkey]]
公钥K（x和y坐标连接并显示为十六进制）：

----
K = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e...
----

[NOTE]
====
值得注意的是，在计算地址时，公钥未使用前缀（十六进制）04格式化。
====

我们使用Keccak-256来计算这个公钥的哈希值：

[[calculate_hash]]
----
Keccak256(K) = 2a5bc342ed616b5ba5732269001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

然后我们只保留最后20个字节（最低有效字节），这是我们的以太坊地址：

[[keep_last_20]]
----
001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

大多数情况下，你会看到前缀为0x的以太坊地址，表示它们是十六进制编码的，如下所示：

[[hex_prefix]]
----
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

[[eth_address_format]]
==== 以太坊地址格式

以太坊地址是十六进制数，是从公钥的Keccak-256哈希的最后20个字节派生的标识符。

与比特币地址不同，比特币地址在所有客户端的用户界面中编码，包括内置checksum以防止错误输入的地址，以太坊地址以原始十六进制形式呈现，没有任何校验和。

该决定背后的理由是，以太坊地址最终会隐藏在系统较高层的抽象（例如名称服务）之后，并且必要时应在更高层添加校验和。

实际上，这些更高层的开发速度太慢，这种设计选择导致了生态系统早期的许多问题，包括由于错误的地址和输入验证错误导致的资金损失。此外，由于以太坊名称服务的开发速度比最初预期的要慢，因此替代编码非常缓慢地被钱包开发人员采用。接下来我们将介绍一些编码选项。

[[ICAP]]
==== Inter Exchange Client Address Protocol（内部交换客户地址协议）

内部交换客户地址协议（ICAP）是一种以太坊地址编码，它与International Bank Account Number（国际银行帐号）（IBAN）编码部分兼容，为以太坊地址提供通用，带校验和，可互操作的编码。 ICAP地址可以编码以太坊地址或用以太坊名称注册表注册的通用名称。你可以在 https://github.com/ethereum/wiki/wiki/Inter-exchange-Client-Address-Protocol-(ICAP)[Ethereum Wiki] 上阅读有关ICAP的更多信息。

IBAN是识别银行账号的国际标准，主要用于电汇。它在欧洲单一欧元支付区（SEPA）及其他地区被广泛采用。 IBAN是一种集中且严格监管的服务。 ICAP是以太坊地址的去中心化但兼容的实现。

IBAN由最多34个字母数字字符串组成（不区分大小写），包括国家/地区代码，校验和和银行帐户标识符（特定于国家/地区）。

ICAP使用相同的结构，引入了一个非标准的国家代码“XE”，代表“以太坊”，后面是两个字符的校验和以及三种可能的帐户标识变体：

Direct:: 一个big-endian base-36整数，由最多30个字母数字字符组成，代表以太坊地址的155个最低有效位。由于此编码比一般以太网地址的完整160位小，因此它仅适用于以一个或多个零字节开头的以太坊地址。优点是它在字段长度和校验和方面与IBAN兼容。示例：XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD（长度为33个字符）。

Basic:: 与Direct编码相同，但长度为31个字符。这允许它编码任何以太坊地址，但使其与IBAN字段验证不兼容。示例：XE18CHDJBPLTBCJ03FE9O2NS0BPOJVQCU2P（长度为35个字符）。

Indirect:: 对通过名称注册表提供程序解析为以太坊地址的标识符进行编码。它使用16个字母数字字符，包括资产标识符（例如，ETH），名称服务（例如，XREG）和9个字符的人类可读名称（例如，KITTYCATS）。示例：XE##ETHXREGKITTYCATS（长度为20个字符），其中##应替换为两个计算的校验和字符。

我们可以使用helpeth命令行工具来创建ICAP地址。让我们尝试使用我们的示例私钥（前缀为0x并作为参数传递给helpeth）：

++++
<pre data-type="programlisting">
$ <strong>helpeth keyDetails \
  -p 0xf8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315</strong>

Address: 0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
ICAP: XE60 HAMI CDXS V5QX VJA7 TJW4 7Q9C HWKJ D
Public key: 0x6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b...
</pre>
++++

helpeth命令为我们构造十六进制以太坊地址和ICAP地址。我们的示例密钥的ICAP地址是：

[[ICAP_example]]
----
XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD
----

因为我们的示例以太坊地址恰好以一个零字节开始，所以可以使用在IBAN格式中合法的Direct ICAP编码方法对其进行编码。它长33个字符。

如果我们的地址不以零字节开头，则它将使用基本编码进行编码，该编码长度为35个字符且不是合法的IBAN。

[TIP]
====
以零字节开头的任何以太坊地址的可能性为1/256。为了生成这样的一个，在我们找到一个与IBAN兼容的“Direct”编码的一个ICAP地址之前，它将平均需要256次尝试和256个不同的随机私钥。
====

目前，不幸的是，只有少数钱包支持ICAP。

[[EIP55]]
==== Hex Encoding with Checksum in Capitalization使用大写校验和的十六进制编码（EIP-55）

由于ICAP和名称服务的部署缓慢， https://github.com/Ethereum/EIPs/blob/master/EIPS/eip-55.md[Ethereum Improvement Proposal 55 (EIP-55)] 提出了一个标准。 EIP-55通过修改十六进制地址的大小写，为以太坊地址提供向后兼容的校验和。这个想法是以太坊地址不区分大小写，并且所有钱包都应该接受以大写或小写字母表示的以太坊地址，而在解释上没有任何区别。

通过修改地址中字母字符的大小写，我们可以传达一个校验和，可用于保护地址的完整性，防止输入或读取错误。不支持EIP-55校验和的钱包只是忽略了地址包含混合大小写的事实，但那些支持它的钱包可以验证它并以99.986％的准确度检测错误。

混合大小写编码是微妙的，你可能不会首先注意到它。我们的示例地址是：

----
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

使用EIP-55混合大小写校验和，它变为：

[[mixed_capitalization]]
----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
----

你能分辨出来吗？十六进制编码字母表中的一些字母（A-F）字符现在是大写字母，而其他字母则是小写字母。

EIP-55实现起来非常简单。我们采用小写十六进制地址的Keccak-256哈希。此哈希充当地址的数字指纹，为我们提供方便的校验和。输入（地址）的任何微小变化都会导致产生的哈希（校验和）发生重大变化，从而使我们能够有效地检测错误。然后我们地址的哈希值以地址本身的大小写形式编码。让我们一步一步地分解它：

1. 哈希小写地址，不带0x前缀：

[[hash_lower_case_address]]
----
Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0f9") =
23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9695d9a19d8f673ca991deae1
----

[start=2]
1. 如果哈希的相应十六进制数字大于或等于0x8，则将每个字母地址字符大写。如果我们把地址和哈希排列在一起，这更容易显示：

[[capitalize_input]]
----
Address: 001d3f1ef827552ae1114027bd3ecf1f086ba0f9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
----

我们的地址在第四个位置包含一个字母字符d。哈希的第四个字符是6，小于8.因此，我们将保留d小写。我们地址中的下一个字母字符是f，位于第六位。十六进制哈希的第六个字符是c，它大于8.因此，我们将地址中的F大写，依此类推。如你所见，我们仅使用散列的前20个字节（40个十六进制字符）作为校验和，因为我们在地址中只有20个字节（40个十六进制字符）以适当地大写。

自己检查生成的混合大小写地址，看看是否可以分辨哪些字符是大写，哪些字符是小写，以及它们在地址哈希中对应的字符：

[[capitalize_output]]
----
Address: 001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
----

[[EIP55_error]]
===== 检测EIP-55编码地址中的错误

现在，让我们看看EIP-55地址将如何帮助我们找到错误。假设我们已经打印出一个以太坊地址，这是EIP-55编码的：

[[correct_address]]
----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
----

现在让我们在阅读该地址时犯一个基本错误。最后一个字符前面的字符是大写字母F.对于这个例子，我们假设我们把它误读为大写字母E，我们在钱包中输入以下（不正确的）地址：

[[incorrect_address]]
----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
----

幸运的是，我们的钱包符合EIP-55标准！它注意到混合大写并尝试验证地址。它将它转换为小写，并计算校验和（checksum）哈希：

[[hash_demo]]
----
Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0e9") =
5429b5d9460122fb4b11af9cb88b7bb76d8928862e0a57d46dd18dd8e08a6927
----

正如你所看到的，即使地址仅改变了一个字符（实际上只有一个位，因为e和f相隔一位），地址的哈希也发生了根本改变。这是哈希函数的属性，使它们对校验和非常有用！

现在，让我们把地址和哈希排列在一起并检查大小写：

[[incorrect_capitalization]]
----
001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
5429b5d9460122fb4b11af9cb88b7bb76d892886...
----

这都错了！几个字母字符的大写不正确。请记住，大小写是正确校验和的编码。

我们输入的地址的大小写与刚刚计算的校验和不匹配，这意味着地址中的某些内容发生了变化，并且引入了错误。


[[keys-addresses-conclusions]]
=== 总结

在本章中，我们简要介绍了公钥密码学，重点介绍了以太坊中公钥和私钥的使用，以及在以太坊地址的创建和验证中使用加密工具（如哈希函数）。我们还研究了数字签名以及它们如何在不泄露私钥的情况下证明私钥的所有权。在[wallets_chapter]中，我们将把这些想法放在一起，看看如何使用钱包来管理密钥集合。
