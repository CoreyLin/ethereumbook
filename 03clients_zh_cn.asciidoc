[[ethereum_clients_chapter]]
== 以太坊客户端

一个以太坊客户端是一个软件应用程序，它实现以太坊规范并通过对等网络与其他以太坊客户端进行通信。如果不同的以太坊客户端符合参考规范和标准化通信协议，则可以进行交互操作。虽然这些不同的客户端由不同的团队和不同的编程语言实现，但他们都“说”相同的协议并遵循相同的规则。因此，它们都可以用于操作相同的以太坊网络并与之交互。

以太坊是一个开源项目，所有主要客户端的源代码都可以在开源许可（例如，LGPL v3.0）下使用，可以免费下载和用于任何目的。但是，开源意味着不仅仅是免费使用。这也意味着以太坊是由一个开放的志愿者社区开发的，任何人都可以修改。更多的眼睛意味着更值得信赖的代码。

以太坊由称为“黄皮书”的正式规范定义（参见<<references>>）。

这与例如比特币形成对比，比特币没有以任何正式方式定义。比特币的“规范”是比特币核心的参考实现，以太坊的规范记录在一篇结合了英语和数学（正式）规范的论文中。除了各种以太坊改进提案（Ethereum Improvement Proposals）之外，此正式规范还定义了以太坊客户端的标准行为。随着以太坊的重大改变，黄皮书会定期更新。

作为以太坊明确的正式规范的结果，以太坊客户端有许多独立开发但可互操作的软件实现。与其他任何区块链相比，以太坊在网络上运行的实现更加多样化，这通常被认为是一件好事。事实上，它已经证明自己是抵御网络攻击的一种很好的方法，因为利用特定客户端的实现策略只会在开发人员修补漏洞和开发补丁时麻烦开发人员，而其他客户端则保持网络运行几乎不受影响。

=== 以太坊网络

存在各种基于以太坊的网络，这些网络很大程度上符合以太坊黄皮书中定义的正式规范，但有可能相互之间不能交互操作。

在这些基于以太坊的网络中有Ethereum, Ethereum Classic, Ella, Expanse, Ubiq, Musicoin等等。虽然在协议级别大多兼容，但这些网络通常具有要求以太坊客户端软件维护人员进行微小更改以支持每个网络的功能或属性。

目前，以太坊协议有六种主要实现，用六种不同的语言编写：

* Parity, written in Rust
* Geth, written in Go
* +cpp-ethereum+, written in Cpass:[++]
* +pyethereum+, written in Python
* Mantis, written in Scala
* Harmony, written in Java

在本节中，我们将介绍两个最常见的客户端，Parity和Geth。我们将展示如何使用每个客户端设置一个节点，并探索它们的一些命令行选项和应用程序编程接口（API）。

[[full_node_importance]]
==== 我应该运行一个完整节点吗？

区块链的健康，弹性和抗审查能力取决于它们具有许多独立操作和地理上分散的完整节点。每个完整节点可以帮助其他新节点获取区块数据以引导其操作，并为操作员提供对所有交易和合约的权威和独立的验证。

但是，运行完整节点将导致硬件资源和带宽成本增加。完整节点必须下载80-100 GB的数据（截至2018年9月，具体取决于客户端配置）并将其存储在本地硬盘驱动器上。随着新交易和区块的增加，这种数据负担每天都在迅速增加。我们将在<<requirements>>中更详细地讨论此主题。

以太坊开发不需要在实时主网上运行的完整节点。你可以使用一个testnet节点（将你连接到一个较小的公共测试区块链），或使用本地私有区块链（如Ganache），或使用由Infura等服务提供商提供的基于云的以太坊客户端执行几乎所有操作。

你还可以选择运行远程客户端，该客户端不存储区块链的本地副本或验证区块和交易。这些客户端提供钱包的功能，可以创建和广播交易。远程客户端可用于连接到现有网络，例如你自己的完整节点，公共区块链，公共或许可（权威证明）testnet或私有本地区块链。实践中，你可能会使用MetaMask，Emerald Wallet，MyEtherWallet或MyCrypto等远程客户端作为在所有不同节点选项之间切换的便捷方式。

术语“远程客户端”和“钱包”可互换使用，但存在一些差异。通常，除了钱包的交易功能之外，远程客户端还提供API（例如web3.js API）。

不要将以太坊中远程钱包的概念与轻客户端的概念混淆（类似于比特币中的简化支付验证客户端）。 轻客户端验证区块头并使用Merkle证明来验证区块链中的交易是否被包含并确定它们的影响，从而为它们提供与完整节点类似的安全级别。相反，以太坊远程客户端不验证区块头或交易。他们完全信任一个完整的客户端，让它们访问区块链，因此失去了重要的安全性和匿名性保证。你可以使用自己运行的完整客户端来缓解这些问题。

[[full_node_adv_disadv]]
==== 完整节点的优缺点
选择运行完整节点有助于你连接到的网络的运行，但也会产生一些轻微到中等的成本。让我们看看有哪些优点和缺点。

*优点：*

* 支持基于以太坊的网络的弹性和抗审查能力
* 权威地验证所有交易
* 无需中介即可与公共区块链上的任何合约互动
* 可以在没有中介的情况下直接将合约部署到公共区块链中
* 可以离线查询（只读）区块链状态（帐户，合约等）
* 可以在不让第三方知道你正在阅读的信息的情况下查询区块链

*缺点：*

* 需要大量且不断增长的硬件和带宽资源
* 首次启动时可能需要几天才能完全同步
* 必须维护，升级并保持在线才能保持同步

[[pub_test_adv_disadv]]
==== 公共Testnet的优缺点

无论你是否选择运行一个完整节点，你可能都希望运行一个公共testnet节点。让我们看看使用一个公共testnet的一些优点和缺点。

*优点：*

* 一个testnet节点需要同步和存储的数据更少得多 - 大约10GB，具体取决于网络（截至2018年4月）。
* 一个testnet节点可以在几个小时内完全同步。
* 部署合约或发起交易需要测试ether，它没有价值，可以从几个“faucets”免费获得。
* Testnets是具有许多其他用户和合约的公共区块链，“实时”运行。

*缺点：*

* 你不能在testnet上使用“真正的”钱;它运行在测试ether上。因此，你无法测试真实敌对者的安全性，因为没有任何利害关系。
* 一个公共区块链的某些方面无法在testnet上进行实际测试。例如，交易费虽然是发送交易所必需的，但并不是testnet上的考虑因素，因为gas是免费的。此外，testnet不像公共主网有时会经历网络拥塞。

[[localtest_adv_dis]]
==== 本地区块链模拟的优缺点

出于许多测试目的，最佳选择是启动单例私有区块链。 Ganache（以前称为testrpc）是你可以与之互动的最受欢迎的本地区块链模拟之一，没有任何其他参与者。它共享了公共testnet的许多优点和缺点，但也有一些差异。

*优点：*

* 磁盘上没有同步，并且几乎没有数据。你自己挖掘第一个区块
* 无需获得测试ether：你可以“奖励”自己可以用于测试的挖矿奖励
* 没有其他用户，只有你
* 没有其他合约，只有你在启动它之后部署的合约

*缺点：*

* 没有其他用户意味着它的行为与公共区块链的行为不同。交易空间或交易顺序没有竞争
* 除了你以外，没有矿工意味着挖矿更具可预测性;因此，你无法测试公共区块链上发生的某些情况
* 没有其他合约意味着你必须部署要测试的所有东西，包括依赖项和合约库
* 你无法重新创建某些公共合约及其地址以测试某些场景（例如，DAO合约）


[[running_client]]
=== 运行一个以太坊客户端

如果你有时间和资源，则应尝试运行完整节点，即使只是为了了解有关该过程的更多信息。在本节中，我们将介绍如何下载，编译和运行以太坊客户端Parity和Geth。这需要熟悉在操作系统上使用命令行界面。无论你选择将它们作为完整节点，作为testnet节点还是作为本地私有区块链的客户端运行，都值得安装这些客户端。

[[requirements]]
==== 一个完整节点的硬件要求

在开始之前，你应确保拥有一台具有足够资源的计算机来运行以太坊完整节点。你将需要至少80 GB的磁盘空间来存储以太坊区块链的完整副本。如果你还想在以太坊testnet上运行完整节点，则至少还需要额外的15 GB。下载80 GB的区块链数据可能需要很长时间，因此建议你使用快速的Internet连接。

同步以太坊区块链是非常输入/输出(I/O)密集型的。最好有一个固态硬盘驱动器（SSD）。如果你有一个机械硬盘驱动器（HDD），则至少需要8 GB的RAM用作缓存。否则，你可能会发现系统太慢而无法跟上并完全同步。

*最低要求*

* 具有2+内核的CPU
* 至少80 GB的可用存储空间
* SSD最少4 GB RAM，如果是HDD，则8 GB +
* 8 MBit/sec的Internet下载服务

这些是同步基于以太坊区块链的完整（但已修剪）副本的最低要求。

在撰写本文时，Parity代码库的资源更轻，因此如果你使用有限的硬件运行，你可能会看到使用Parity会有更好的结果。

如果你想在合理的时间内同步并存储我们在本书中讨论的所有开发工具，库，客户端和区块链，你将需要一台功能更强大的计算机。

*建议规范*

* 具有4+内核的快速CPU
* 16 GB+ RAM
* 具有至少500 GB可用空间的快速SSD
* 25+ MBit/sec的Internet下载服务

很难预测区块链的大小会增加多快以及何时需要更多磁盘空间，因此建议在开始同步之前检查区块链的最新大小。

[NOTE]
====
此处列出的磁盘大小要求假设你将运行具有默认设置的节点，其中区块链的旧状态数据被“修剪”过。如果你改为运行一个完整的“归档”节点，其中所有状态都保存在磁盘上，则可能需要超过1 TB的磁盘空间。
====

这些链接提供区块链大小的最新估计：

* https://bitinfocharts.com/ethereum/[Ethereum]

* https://bitinfocharts.com/ethereum%20classic/[Ethereum Classic]

[[sw_reqs]]
==== 构建和运行客户端（节点）的软件要求

本节介绍Parity和Geth客户端软件。它还假设你使用的是类Unix的命令行环境。这些示例显示了在运行bash shell（命令行执行环境）的Ubuntu GNU / Linux操作系统上出现的命令和输出。

通常，每种区块链都有自己的Geth版本，而Parity通过下载的相同的客户端为多个基于以太坊的区块链（Ethereum, Ethereum Classic, Ellaism, Expanse, Musicoin）提供支持。

[TIP]
=====
在本章的许多示例中，我们将使用通过“终端”应用程序访问的操作系统的命令行界面（也称为“shell”）。 shell会显示提示;输入一个命令，shell响应一些文本和下一个命令的新提示。你的系统上的提示可能看起来不同，但在以下示例中，它由$符号表示。在示例中，当你在$符号后面看到文本时，请不要键入$符号，而是紧跟其后键入命令（以粗体显示），然后按Enter执行命令。在示例中，每个命令下面的行是操作系统对该命令的响应。当你看到下一个$前缀时，你会知道它是一个新命令，你应该重复这个过程。
=====

在我们开始之前，你需要检查是否已安装某些软件。如果你从未在当前使用的计算机上进行任何软件开发，则可能需要安装一些基本工具。对于下面的示例，您需要安装源代码管理系统git; golang，Go编程语言和标准库;和Rust，一种系统编程语言。

可以按照 https://git-scm.com[] 上的说明安装Git。

可以按照 https://golang.org[] 上的说明安装Go。

[NOTE]
=====
Geth的要求各不相同，但如果你坚持使用Go 1.10或更高版本，你应该能够编译你想要的任何版本的Geth。当然，你应该始终参考你选择的Geth风格的文档。

安装在操作系统上或可从系统的软件包管理器获得的golang版本可能远远比1.10老。如果是这样，请将其删除并从 https://golang.org/[_golang.org_] 安装最新版本。
=====

可以按照 https://www.rustup.rs/[] 上的说明安装Rust。

[NOTE]
=====
Parity需要Rust版本1.27或更高版本。
=====

Parity还需要一些软件库，例如OpenSSL和libudev。要在Ubuntu或Debian GNU/Linux兼容系统上安装它们，请使用以下命令：

++++
<pre data-type="programlisting">
$ <strong>sudo apt-get install openssl libssl-dev libudev-dev cmake</strong>
</pre>
++++

对于其他操作系统，请使用操作系统的软件包管理器或按照 https://github.com/paritytech/parity/wiki/Setup[Wiki instructions] 安装所需的库。

现在你已经安装了git，golang，Rust和必要的库，让我们开始工作吧！

[[parity]]
==== Parity

Parity是完整节点以太坊客户端和DApp浏览器的实现。它是在系统编程语言Rust中“从头开始”编写的，旨在构建模块化，安全且可扩展的以太坊客户端。Parity由英国公司Parity Tech开发，并根据GPLv3免费软件许可证发布。

[NOTE]
=====
披露：本书的作者之一Gavin Wood是Parity Tech的创始人，并撰写了Parity客户端的很大部分。Parity占安装的以太坊客户群的25％左右。
=====

要安装Parity，你可以使用Rust包管理器cargo或从GitHub下载源代码。包管理器也下载源代码，因此两个选项之间没有太大区别。在下一节中，我们将向你展示如何自己下载和编译Parity。

[[install_parity]]
===== 安装Parity

https://wiki.parity.io/Setup[Parity Wiki] 提供了在不同环境和容器中构建Parity的说明。我们将向你展示如何从源代码构建Parity。这假设你已经使用rustup安装了Rust（请参阅<<sw_reqs>>）。

首先，从GitHub获取源代码：

++++
<pre data-type="programlisting">
$ <strong>git clone https://github.com/paritytech/parity</strong>
</pre>
++++

然后切换到parity目录并使用cargo来构建可执行文件：

++++
<pre data-type="programlisting">
$ <strong>cd parity</strong>
$ <strong>cargo install</strong>
</pre>
++++

如果一切顺利，你应该看到类似的东西：

++++
<pre data-type="programlisting">
$ <strong>cargo install</strong>
    Updating git repository `https://github.com/paritytech/js-precompiled.git`
 Downloading log v0.3.7
 Downloading isatty v0.1.1
 Downloading regex v0.2.1

 [...]

Compiling parity-ipfs-api v1.7.0
Compiling parity-rpc v1.7.0
Compiling parity-rpc-client v1.4.0
Compiling rpc-cli v1.4.0 (file:///home/aantonop/Dev/parity/rpc_cli)
Finished dev [unoptimized + debuginfo] target(s) in 479.12 secs
$
</pre>
++++

通过调用--version选项尝试并运行parity以查看它是否已安装：


++++
<pre data-type="programlisting">
$ <strong>parity --version</strong>
Parity
  version Parity/v1.7.0-unstable-02edc95-20170623/x86_64-linux-gnu/rustc1.18.0
Copyright 2015, 2016, 2017 Parity Technologies (UK) Ltd
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

By Wood/Paronyan/Kotewicz/Drwięga/Volf
   Habermeier/Czaban/Greeff/Gotchac/Redmann
$
</pre>
++++

很好！现在已经安装了Parity，你可以同步区块链并开始使用一些基本的命令行选项。

[[go_ethereum_geth]]
==== Go-Ethereum (Geth)

Geth是由以太坊基金会积极开发的Go语言实现，因此被认为是以太坊客户端的“官方”实现。通常，每个基于以太坊的区块链都有自己的Geth实现。如果你正在运行Geth，那么你需要确保使用以下仓库链接之一获取区块链的正确版本：


* https://github.com/ethereum/go-ethereum[Ethereum] (or https://geth.ethereum.org/)

* https://github.com/ethereumproject/go-ethereum[Ethereum Classic]

* https://github.com/ellaism/go-ellaism[Ellaism]

* https://github.com/expanse-org/go-expanse[Expanse] 

* https://github.com/Musicoin/go-musicoin[Musicoin] 

* https://github.com/ubiq/go-ubiq[Ubiq] 

[NOTE]
=====
你也可以跳过这些说明，并为你选择的平台安装预编译的二进制文件。预编译版本更容易安装，可以在此处列出的任何仓库的“releases”部分中找到。但是，你可以通过自行下载和编译软件来学习更多东西。
=====

[[cloning_repo]]
===== 克隆仓库

第一步是克隆Git仓库，以获取源代码的副本。

要创建所选仓库的一份本地克隆，请在家目录中或在用于开发的任何目录下使用git命令，如下所示：

++++
<pre data-type="programlisting">
$ <strong>git clone &lt;Repository Link&gt;</strong>
</pre>
++++

将仓库复制到本地系统时，你应该看到进度报告：

[[cloning_status]]
----
Cloning into 'go-ethereum'...
remote: Counting objects: 62587, done.
remote: Compressing objects: 100% (26/26), done.
remote: Total 62587 (delta 10), reused 13 (delta 4), pack-reused 62557
Receiving objects: 100% (62587/62587), 84.51 MiB | 1.40 MiB/s, done.
Resolving deltas: 100% (41554/41554), done.
Checking connectivity... done.
----

很好！现在你已拥有一份Geth的本地副本，你可以为你的平台编译可执行文件。

[[build_geth_src]]
===== 从源代码构建Geth

要构建Geth，请切换到下载源代码的目录并使用make命令：

++++
<pre data-type="programlisting">
$ <strong>cd go-ethereum</strong>
$ <strong>make geth</strong>
</pre>
++++

如果一切顺利，你将看到Go编译器构建每个组件，直到它生成geth可执行文件：

[[making_geth_status]]
----
build/env.sh go run build/ci.go install ./cmd/geth
>>> /usr/local/go/bin/go install -ldflags -X main.gitCommit=58a1e13e6dd7f52a1d...
github.com/ethereum/go-ethereum/common/hexutil
github.com/ethereum/go-ethereum/common/math
github.com/ethereum/go-ethereum/crypto/sha3
github.com/ethereum/go-ethereum/rlp
github.com/ethereum/go-ethereum/crypto/secp256k1
github.com/ethereum/go-ethereum/common
[...]
github.com/ethereum/go-ethereum/cmd/utils
github.com/ethereum/go-ethereum/cmd/geth
Done building.
Run "build/bin/geth" to launch geth.
$
----

让我们确保geth可以工作而不实际开始运行：

++++
<pre data-type="programlisting">
$ <strong>./build/bin/geth version</strong>

Geth
Version: 1.6.6-unstable
Git Commit: 58a1e13e6dd7f52a1d5e67bee47d23fd6cfdee5c
Architecture: amd64
Protocol Versions: [63 62]
Network Id: 1
Go Version: go1.8.3
Operating System: linux
[...]
</pre>
++++

你的geth version命令可能会显示略有不同的信息，但你应该看到的版本报告与此处显示的版本报告非常相似。

不要运行geth，因为它将以“缓慢的方式”开始同步区块链，这将花费太长时间（几周）。接下来的部分将解释以太坊的区块链初始同步带来的挑战。


[[first_sync]]
=== 基于以太坊区块链的第一次同步

通常，在同步以太坊区块链时，你的客户端将从一开始就下载并验证每个区块和每笔交易，即从创世区块开始。

虽然可以通过这种方式完全同步区块链，但是同步将花费很长时间并且具有很高的资源要求（它将需要更多的RAM，如果你没有快速存储，则需要很长时间） 。

许多基于以太坊的区块链是2016年底拒绝服务攻击的受害者。受影响的区块链在进行完全同步时往往会很缓慢。

例如，在以太坊上，新客户端同步将快速进展，直至达到第2,283,397区块。该区块于2016年9月18日被挖矿，标志着DoS攻击的开始。从此块到块2,700,031（2016年11月26日），交易验证变得非常缓慢，内存密集，I/O密集。这导致每个区块的验证时间超过1分钟。以太坊使用硬分叉实施了一系列升级，以解决DoS攻击中被利用的潜在漏洞。这些升级还通过删除垃圾邮件交易创建的大约2000万个空帐户来清理区块链。

如果要以完整验证的方式同步，则客户端将变慢并可能需要几天甚至更长时间来验证受DoS攻击影响的区块。

幸运的是，大多数以太坊客户端都包含一个执行“快速”同步的选项，该同步会跳过交易的完整验证，直到它同步到区块链的尖端，然后继续完整验证。

对于Geth，启用快速同步的选项通常称为--fast。你可能需要参考所选以太坊区块链的具体说明。

Parity默认情况下会快速同步。

[NOTE]
=====
Geth只能在使用一个空的区块数据库启动时运行快速同步。如果你已经开始同步，但没有使用快速模式，Geth无法切换。删除区块链数据目录并从头开始快速同步比继续以完整验证方式的同步更快。删除区块链数据时，请注意不要删除任何钱包！
=====

==== 运行Geth或Parity

现在你已了解“首次同步”的挑战，你已准备好启动以太坊客户端并同步区块链。对于Geth和Parity，你可以使用--help选项查看所有配置参数。对于Geth，除了使用--fast之外，如上一节所述，默认设置通常是合理的，适合大多数用途。选择如何配置任何可选参数以满足你的需求，然后启动Geth或Parity以同步链。然后等待......

[TIP]
====
在具有大容量RAM的非常快速的系统上，同步以太坊区块链将花费半天时间，在较慢的系统上，同步以太坊区块链将花费几天时间。
====

[[json_rpc]]
==== The JSON-RPC Interface

以太坊客户端提供应用程序编程接口和一组远程过程调用（RPC）命令，这些命令被编码为JavaScript Object Notation（JSON）。你将看到这被称为JSON-RPC API。本质上，JSON-RPC API是一个接口，允许我们编写使用以太坊客户端作为以太坊网络和区块链的网关的程序。

通常，RPC接口在端口8545上作为HTTP服务提供。出于安全原因，默认情况下，它仅限于接受来自localhost（你自己计算机的IP地址，即127.0.0.1）的连接。

要访问JSON-RPC API，你可以使用一个专用库（使用你选择的编程语言编写），提供与每个可用RPC命令相对应的“存根”函数调用，或者你可以手动构造HTTP请求并发送/接收JSON编码的请求。你甚至可以使用通用命令行HTTP客户端（如curl）来调用RPC接口。我们试试吧。首先，确保已配置并运行Geth，然后切换到新的终端窗口（例如，在现有终端窗口中使用Ctrl-Shift-N或Ctrl-Shift-T），如下所示：

++++
<pre data-type="programlisting">
$ <strong>curl -X POST -H "Content-Type: application/json" --data \
  '{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1}' \
  http://localhost:8545</strong>

{"jsonrpc":"2.0","id":1,
"result":"Geth/v1.8.0-unstable-02aeb3d7/linux-amd64/go1.8.3"}
</pre>
++++

在此示例中，我们使用curl建立到地址 _http://localhost:8545_ 的HTTP连接。我们已经在运行geth，它在端口8545上提供JSON-RPC API作为HTTP服务。我们指示curl使用HTTP POST命令并将内容标识为类型application / json。最后，我们传递一个JSON编码的请求作为HTTP请求的数据组件。我们的大多数命令行只是设置curl以正确建立HTTP连接。有趣的部分是我们发出的实际JSON-RPC命令：

[[JSON_RPC_command]]
----
{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1}
----

JSON-RPC请求根据 https://www.jsonrpc.org/specification[JSON-RPC 2.0 specification] 进行格式化。每个请求包含四个元素：

++jsonrpc++:: JSON-RPC协议的版本。这必须是“2.0”。

++method++:: 要调用的方法的名称。

++params++:: 一个结构化值，用于保存在调用方法期间要使用的参数值。该成员可以被省略。

++id++:: 客户端建立的标识符，如果包含，必须包含String，Number或NULL值。如果包含，服务器必须在响应对象中回复相同的值。该成员用于关联两个对象之间的上下文。

[TIP]
====
id参数主要用于在单个JSON-RPC调用中发出多个请求时，这种做法称为批处理。批处理用于避免每个请求的新HTTP和TCP连接的开销。例如，在以太坊上下文中，如果我们想通过一个HTTP连接检索数千个交易，我们将使用批处理。批处理时，为每个请求设置不同的id，然后将其与来自JSON-RPC服务器的每个响应中的id匹配。实现此目的的最简单方法是维护计数器并增加每个请求的id值。
====


我们收到的响应是：

----
{"jsonrpc":"2.0","id":1,
"result":"Geth/v1.8.0-unstable-02aeb3d7/linux-amd64/go1.8.3"}
----

这告诉我们Geth客户端版本1.8.0正在提供JSON-RPC API。

让我们尝试更有趣的事情。在下一个示例中，我们向JSON-RPC API询问当前的gas价格（单位为wei）：

++++
<pre data-type="programlisting">
$ <strong>curl -X POST -H "Content-Type: application/json" --data \
  '{"jsonrpc":"2.0","method":"eth_gasPrice","params":[],"id":4213}' \
  http://localhost:8545</strong>

{"jsonrpc":"2.0","id":4213,"result":"0x430e23400"}
</pre>
++++

响应0x430e23400告诉我们，目前的gas价格是1.8 gwei（gigawei或十亿wei）。如果像我们一样，你不用十六进制思考，你可以在命令行上用一点bash-fu将它转换为十进制：

++++
<pre data-type="programlisting">
$ <strong>echo $((0x430e23400))</strong>

18000000000
</pre>
++++

可以在 https://github.com/ethereum/wiki/wiki/JSON-RPC[Ethereum wiki] 上学习完整的JSON-RPC API。

[[parity_compatibility_mode]]
===== Parity的Geth兼容模式

Parity有一个特殊的“Geth兼容模式”，它提供的JSON-RPC API与Geth提供的相同。要在此模式下运行Parity，请使用--geth开关：

++++
<pre data-type="programlisting">
$ <strong>parity --geth</strong>
</pre>
++++

[[lw_eth_clients]]
=== 远程以太坊客户端

远程客户端提供完整客户端功能的子集。它们不存储完整的以太坊区块链，因此它们设置起来更快，并且需要更少的数据存储。

这些客户端通常提供执行以下一项或多项操作的能力：

* 管理钱包中的私钥和以太坊地址。
* 创建，签署和广播交易。
* 使用数据负载与智能合约进行交互。
* 浏览DApps并与之交互。
* 提供外部服务的链接，例如区块浏览器。
* 转换ether单位并从外部来源检索汇率。
* 将web3实例作为JavaScript对象注入Web浏览器。
* 使用由另一个客户端提供/注入浏览器的web3实例。
* 访问本地或远程以太坊节点上的RPC服务。

某些远程客户端（例如移动（智能手机）钱包）仅提供基本钱包功能。其他远程客户端是完整的DApp浏览器。远程客户端通常提供全节点以太坊客户端的一些功能，而无需通过连接到其他地方运行的完整节点来同步以太坊区块链的本地副本，例如，由你本地在你的计算机或Web服务器上，或由你服务器上的第三方。

让我们来看看一些最流行的远程客户端及其提供的功能。

[[mobile_wallets]]
====移动（智能手机）钱包

所有移动钱包都是远程客户端，因为智能手机没有足够的资源来运行完整的以太坊客户端。轻客户端正在开发中，而不是通常用于以太坊。在Parity的情况下，light客户端标记为“experimental”，可以通过使用--light选项运行parity来使用。

流行的移动钱包包括以下内容（我们仅将这些列为示例;这不是对这些钱包的安全性或功能的背书或指示）：

https://jaxx.io[Jaxx]:: 基于BIP-39助记词种子的多货币手机钱包，支持Bitcoin, Litecoin, Ethereum, Ethereum Classic, ZCash，各种ERC20通证以及许多其他货币。 Jaxx可在Android和iOS上使用，可作为浏览器插件钱包使用，也可作为各种操作系统的桌面钱包使用。

https://status.im[Status]:: 移动钱包和DApp浏览器，支持各种通证和流行的DApp。适用于iOS和Android。

https://trustwalletapp.com/[Trust Wallet]:: 以太坊和以太坊Classic的移动钱包，支持ERC20和ERC223通证。 Trust Wallet适用于iOS和Android。找到它

https://www.cipherbrowser.com[Cipher Browser]::  全功能的支持以太坊的移动DApp浏览器和钱包，允许与以太坊应用程序和通证集成。适用于iOS和Android。

[[browser_wallets]]
==== 浏览器钱包

各种钱包和DApp浏览器可用作Chrome和Firefox等Web浏览器的插件或扩展。这些是在浏览器中运行的远程客户端。

一些比较流行的是MetaMask, Jaxx, MyEtherWallet/MyCrypto和Mist。

[[MetaMask]]
===== MetaMask

在<<intro_chapter>>中引入的 https://metamask.io/[MetaMask] 是一个基于浏览器的多功能钱包，RPC客户端和基本合约浏览器。它适用于Chrome，Firefox，Opera和Brave Browser。

与其他浏览器钱包不同，MetaMask将一个web3实例注入基于浏览器，充当RPC客户端，连接到各种以太坊区块链（mainnet，Ropsten testnet，Kovan testnet，本地RPC节点等）。注入web3实例并充当外部RPC服务的网关的能力使MetaMask成为开发人员和用户都非常强大的工具。例如，它可以与MyEtherWallet或MyCrypto结合使用，充当这些工具的web3提供者和RPC网关。

[[Jaxx]]
===== Jaxx

https://jaxx.io[Jaxx] 在上一部分作为移动钱包介绍，也可作为Chrome和Firefox扩展以及桌面钱包使用。

[[MEW]]
===== MyEtherWallet (MEW)

https://www.myetherwallet.com/[MyEtherWallet] 是一个基于浏览器的JavaScript远程客户端，提供：

* 一个用JavaScript运行的软件钱包
* 通往Trezor和Ledger等流行硬件钱包的桥梁
* 一个web3接口，可以连接到另一个客户端（例如，MetaMask）注入的web3实例
* 可以连接到以太坊完整客户端的RPC客户端
* 给定一个合约地址和应用程序二进制接口（ABI），可以与智能合约交互的基本接口

MyEtherWallet对于测试和作为硬件钱包的接口非常有用。它不应该用作主要的软件钱包，因为它通过浏览器环境被暴露于威胁，并且不是安全的密钥存储系统。

[WARNING]
====
访问MyEtherWallet和其他基于浏览器的JavaScript钱包时必须非常小心，因为它们经常成为网络钓鱼的目标。始终使用书签而不是搜索引擎或链接来访问正确的Web URL。
====

[[MyCrypto]]
===== MyCrypto

就在本书第一版出版之前，MyEtherWallet项目分为两个竞争实现，由两个独立的开发团队指导：在开源开发中称为一个“fork”。这两个项目被称为MyEtherWallet（原始品牌）和 https://mycrypto.com/[MyCrypto] 。在拆分时，MyCrypto提供了与MyEtherWallet相同的功能，但由于两个开发团队采用不同的目标和优先级，这两个项目很可能会出现分歧。

[[Mist]]
===== Mist

https://github.com/ethereum/mist[Mist] 是由以太坊基金会构建的第一个支持以太坊的浏览器。它包含一个基于浏览器的钱包，它是ERC20通证标准的第一个实现（Fabian Vogelsteller，ERC20的作者，也是Mist的主要开发者）。 Mist也是第一个引入camelCase checksum和（EIP-55）的钱包。 Mist运行完整节点，并提供支持基于Swarm的存储和ENS地址的完整的DApp浏览器。

=== 总结

在本章中，我们探讨了以太坊客户端。你下载，安装并同步了客户端，成为以太坊网络的参与者，并通过在你自己的计算机上复制区块链来促进系统的健康和稳定性。
